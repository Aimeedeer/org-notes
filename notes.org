#+hugo_base_dir: .
#+options: author:Aimee

* Posts
:PROPERTIES:
:EXPORT_HUGO_SECTION: post
:EXPORT_HUGO_MENU: :menu main
:END:
** Walnuts Hacklog             :rust:hacking:blockchain:walnuts:log:@hacking:
:PROPERTIES:
:EXPORT_FILE_NAME: walnuts
:EXPORT_DATE: 2020-11-02
:EXPORT_HUGO_SECTION: hacking
:EXPORT_DESCRIPTION: My hacklog for Walnuts, a toy blockchain.
:EXPORT_OPTIONS: toc:2
:END:

[[https://github.com/Aimeedeer/walnuts][Walnuts source code]]

*** TODO
- [x] sha2 for hash function
- [x] chrono for UTC time as timestamp
- [x] serde for storage, write & read to a file on disc
- [x] cli
- [x] create a new block from commandline, 
      and save it in a json file
- [x] change read & write to serde <> io: 
      https://docs.rs/serde_json/1.0.59/serde_json/fn.from_reader.html
- [x] deal with unwrap() -> Result
- [ ] create transactions from commandline
- [ ] 256k for tx signature: https://docs.rs/k256/0.5.10/k256/
- [ ] nouce verify
- [ ] keep mining
- [ ] clean code
    
*** Hacklog

**** 2020-11-21

Error handling progress:

#+begin_src rust
    pub fn load() -> Result<Self> {
	let file = File::open("walnutsdata.json");
	match file {
	    Ok(file) => { 
		Ok(serde_json::from_reader(&file)?)
	    },
	    Err(e) => {
		if e.kind() == ErrorKind::NotFound {
		    Ok(Blockchain::new())
		} else {		 
		    Err(Error::from(e))
		}
	    }	    
	}

    }

    fn new() -> Self {
	Blockchain { blocks: Vec::new() }
    }

#+end_src

Rust doc:
[[https://doc.rust-lang.org/std/io/enum.ErrorKind.html][Enum std::io::ErrorKind]]


**** 2020-11-20

[[https://docs.rs/serde_json/1.0.59/serde_json/index.html][Crate serde_json]]

A worth reading issue:
[[https://github.com/serde-rs/json/issues/160][Parsing 20MB file using from_reader is slow #160]]

Changes in blockchain.rs: ~unwrap()~ -> ~?~
#+begin_src rust
    pub fn updateblockchain(block: Block) -> Result<()> {
	let f = File::create("walnutsdata.json")?;
	let blockdata = serde_json::ser::to_writer_pretty(f, &block)?;
	println!("write to walnutsdata.json");

	let data = std::fs::read_to_string("walnutsdata.json")?;
	let deserialized: Block = serde_json::from_str(&data)?;
	println!("deserialized data from walnutsdata.json: {:?}", deserialized);
	Ok(())
    }
#+end_src

The output:
#+begin_src shell
$ cargo run -- mine
    Finished dev [unoptimized + debuginfo] target(s) in 1.55s
     Running `target/debug/walnuts mine`
Opt {
    cmd: Mine,
}
write to walnutsdata.json
deserialized data from walnutsdata.json: Block { header: BlockHeader { prev_block_hash: [166, 5, 88, 255, 235, 6, 147, 45, 180, 203, 105, 29, 131, 4, 186, 246, 69, 115, 54, 230, 65, 190, 65, 172, 108, 106, 33, 220, 51, 45, 68, 150], time: 1605002954274, nonce: 1 }, txs: [] }
check mine funtion: Ok(())
#+end_src

I didn't finish implementing ~anyhow::Result~ error handling today.

**** 2020-11-16

- Created a new block (Mine) from commandline, 
  and saved it to walnutsdata.json
- Learned: always thinking in type system

Test the sample code from [[https://serde.rs/][serde.rs]] 
in my blockchain.rs code:

#+begin_src rust
let serialized = serde_json::to_string(&block).unwrap();
println!("serialized = {}", serialized);

let deserialized: Block = serde_json::from_str(&serialized).unwrap();
println!("deserialized = {:?}", deserialized);
#+end_src 

The output:

#+begin_src shell
$ cargo run -- mine

    Finished dev [unoptimized + debuginfo] target(s) in 3.04s
     Running `target/debug/walnuts mine`
Opt {
    cmd: Mine,
}
serialized = {"header":{"prev_block_hash":[166,5,88,255,235,6,147,45,180,203,105,29,131,4,186,246,69,115,54,230,65,190,65,172,108,106,33,220,51,45,68,150],"time":1605002954274,"nonce":1},"txs":[]}
deserialized = Block { header: BlockHeader { prev_block_hash: [166, 5, 88, 255, 235, 6, 147, 45, 180, 203, 105, 29, 131, 4, 186, 246, 69, 115, 54, 230, 65, 190, 65, 172, 108, 106, 33, 220, 51, 45, 68, 150], time: 1605002954274, nonce: 1 }, txs: [] }
Genesis block is: [166, 5, 88, 255, 235, 6, 147, 45, 180, 203, 105, 29, 131, 4, 186, 246, 69, 115, 54, 230, 65, 190, 65, 172, 108, 106, 33, 220, 51, 45, 68, 150]
write to walnutsdata.txt
check mine funtion: Ok(())
#+end_src

Read blockchain data from =walnutsdata.txt=

#+begin_src rust
let fout = File::open("walnutsdata.txt")?;
let mut buf_reader = BufReader::new(fout);
let mut reader = String::new();

buf_reader.read_to_string(&mut reader)?;
println!("read from walnutsdata.txt in string: {:?}", &reader);

let deserialized: Block = serde_json::from_str(&reader).unwrap();
println!("deserialized data from walnutsdata.txt: {:?}", deserialized);
#+end_src 

The output of reading data:

#+begin_src shell
$ cargo run -- mine


    Finished dev [unoptimized + debuginfo] target(s) in 1.09s
     Running `target/debug/walnuts mine`
Opt {
    cmd: Mine,
}
write to walnutsdata.txt
read from walnutsdata.txt in string: "{\"header\":{\"prev_block_hash\":[166,5,88,255,235,6,147,45,180,203,105,29,131,4,186,246,69,115,54,230,65,190,65,172,108,106,33,220,51,45,68,150],\"time\":1605002954274,\"nonce\":1},\"txs\":[]}"
deserialized data from walnutsdata.txt: Block { header: BlockHeader { prev_block_hash: [166, 5, 88, 255, 235, 6, 147, 45, 180, 203, 105, 29, 131, 4, 186, 246, 69, 115, 54, 230, 65, 190, 65, 172, 108, 106, 33, 220, 51, 45, 68, 150], time: 1605002954274, nonce: 1 }, txs: [] }
check mine funtion: Ok(())
#+end_src

Change to =serde_json::to_string_pretty=:

#+begin_src rust
let blockdata = serde_json::to_string_pretty(&block).unwrap();

println!("write to walnutsdata.json");

let f = File::create("walnutsdata.json")?;
{
    let mut buffer = BufWriter::new(f);

    buffer.write_all(&blockdata.as_bytes())?;
    buffer.flush()?;
}

let mut fout = File::open("walnutsdata.json")?;

// future consideration: io & os performance
// let mut buf_reader = BufReader::new(fout);

let mut data = String::new();
fout.read_to_string(&mut data)?;

println!("read from walnutsdata.json in string: {}", &data);

let deserialized: Block = serde_json::from_str(&data).unwrap();
println!("deserialized data from walnutsdata.json: {:?}", deserialized);
	
Ok(())

#+end_src

The pretty output:

#+begin_src shell
    Finished dev [unoptimized + debuginfo] target(s) in 1.08s
     Running `target/debug/walnuts mine`
Opt {
    cmd: Mine,
}
write to walnutsdata.json
read from walnutsdata.json in string: {
  "header": {
    "prev_block_hash": [
      166,
      5,
      88,
      255,
      235,
      6,
      147,
      45,
      180,
      203,
      105,
      29,
      131,
      4,
      186,
      246,
      69,
      115,
      54,
      230,
      65,
      190,
      65,
      172,
      108,
      106,
      33,
      220,
      51,
      45,
      68,
      150
    ],
    "time": 1605002954274,
    "nonce": 1
  },
  "txs": []
}
deserialized data from walnutsdata.json: Block { header: BlockHeader { prev_block_hash: [166, 5, 88, 255, 235, 6, 147, 45, 180, 203, 105, 29, 131, 4, 186, 246, 69, 115, 54, 230, 65, 190, 65, 172, 108, 106, 33, 220, 51, 45, 68, 150], time: 1605002954274, nonce: 1 }, txs: [] }
check mine funtion: Ok(())
#+end_src

**** 2020-11-13

- Learned: 
  - cargo clean: clean the target folder
  - cargo run -- mysubcommand == target/walnuts mysubcommand
  - https://rust-cli.github.io/book/tutorial/cli-args.html
- Use structopt as cli in main.rs
  - When I moved the cli related code to cli.rs, there is an error

#+begin_src shell
error[E0599]: no function or associated item named `from_args` found for struct `Opt` in the current scope
  --> src/main.rs:16:25
   |
16 |     let opt = cli::Opt::from_args();
   |                         ^^^^^^^^^ function or associated item not found in `Opt`
   | 
  ::: src/cli.rs:5:1
   |
5  | pub struct Opt {
   | -------------- function or associated item `from_args` not found for this
   |
   = help: items from traits can only be used if the trait is in scope
help: the following trait is implemented but not in scope; perhaps add a `use` for it:
   |
1  | use structopt::StructOpt;
   |

error: aborting due to previous error

For more information about this error, try `rustc --explain E0599`.
#+end_src

Then I added this piece to previous main.rs, and it built.

#+begin_src rust
use structopt::StructOpt;
#+end_src

**** 2020-11-12

- Cargo check / cargo build
- =std::io= to deal with files
- cli
  - clap
  - structopt: https://docs.rs/structopt/0.3.20/structopt/
    - https://rust-cli.github.io/book/tutorial/cli-args.html

**** 2020-11-11

- Use Tony's =secp256k1= library
- Serde

About serde derive:

#+begin_src shell
error: cannot find derive macro `Serialize` in this scope
 --> src/block.rs:6:10
  |
6 | #[derive(Serialize, Deserialize, Debug)]
  |          ^^^^^^^^^

error: cannot find derive macro `Deserialize` in this scope
#+end_src

Then add feature in Cargo.toml

#+begin_src rust
serde = { version = "1.0.117", features = ["derive"] }
#+end_src

The doc explains:
[[https://serde.rs/derive.html][Using derive]]

**** 2020-11-10

- [[https://docs.rs/chrono/0.4.19/chrono/struct.DateTime.html][Rust: chrono]] for UTC time
- Read: [[https://betweentwocommits.com/blog/how-bitcoin-timestamping-works][How Bitcoin Timestamping Works]] 
>Bitcoin timestamping does not guarantee an exact time. 
Bitcoin miners are calibrated to create blocks approximately 
every ten minutes. 
However, because of the way their protocol works, 
this is only an average. It could be two minutes, or fifteen. 
This means that the time given by a timestamp is 
only precise to within a range of a few hours. 
For most use cases, this is not an issue, 
since getting the date right is more important than 
the minute or second.

>I should mention that the act of inserting non-transactional data 
in the blockchain is a disputed practice. 
As I mentioned earlier, 
the blockchain is now approximately 300 GB, 
and it can only get bigger. Some people believe that 
adding data not directly related to Bitcoin's true purpose - 
managing transactions - needlessly bloats the size of the blockchain, 
and should not be allowed. 
I am in favour of reducing bloat (including 
a restriction now in the protocol to limit the size of the data 
you can insert), but I think that timestamping is an acceptable 
"secondary purpose" for Bitcoin, which opens the door to 
a lot of potential applications, and which promotes 
the use of Bitcoin.

>The easiest application of Bitcoin timestamps 
is a program called opentimestamps, created by Peter Todd himself. 

**** 2020-11-08

- First build
- main: Read =block.hash()=

**** 2020-11-03 

Creat mod
- block.rs
- blockchain.rs
- blockheader.rs
- transaction.rs
- lib.rs

Use hash crate: https://docs.rs/sha2/0.5.2/sha2/
for generating block's hash string.

Some other hash functions written in Rust:
https://github.com/RustCrypto/hashes

**** 2020-11-02 

- Created Walnuts: my toy blockchain in Rust
** Play with Substrate           :rust:substrate:blockchain:hacking:@hacking:
:PROPERTIES:
:EXPORT_FILE_NAME: play-with-substrate
:EXPORT_DATE: 2020-11-15
:EXPORT_HUGO_SECTION: blockchain
:EXPORT_HUGO_LINKTITLE: blockchain
:EXPORT_DESCRIPTION: Substrate is interesting and it seems powerful.
:EXPORT_OPTIONS: toc:2
:END:

*** 2020-11-20 

[[https://substrate.dev/substrate-contracts-workshop/#/0/creating-an-ink-project][Creating an ink! Project]]

Run ~cargo contract new flipper~ again
(I already ran it last time):
#+begin_src shell
$ cargo +nightly contract build
 [1/3] Building cargo project
   Compiling termcolor v1.1.2
   Compiling trybuild v1.0.35
   Compiling ink_lang_macro v3.0.0-rc2
   Compiling ink_lang v3.0.0-rc2
   Compiling flipper v0.1.0 (/var/folders/g5/hf7q78jn0vngnqtqj_3qfm6r0000gn/T/cargo-contract_4mvqYY)
    Finished release [optimized] target(s) in 5.55s
 [2/3] Post processing wasm file
 [3/3] Optimizing wasm file
wasm-opt is not installed. Install this tool on your system in order to 
reduce the size of your contract's Wasm binary. 
See https://github.com/WebAssembly/binaryen#tools
#+end_src	

**** New tool learned

[[https://github.com/dtolnay/cargo-expand][cargo-expand]] by [[https://github.com/dtolnay][dtolnay]].

#+begin_src shell
$ cargo expand --no-default-features
# Compiling...
error: ink! only support compilation as `std` or `no_std` + `wasm32-unknown`
  --> /Users/aimeez/.cargo/registry/src/github.com-1ecc6299db9ec823/ink_env-3.0.0-rc2/src/engine/mod.rs:39:9
   |
39 | /         compile_error! {
40 | |             "ink! only support compilation as `std` or `no_std` + `wasm32-unknown`"
41 | |         }
   | |_________^
error[E0432]: unresolved import `crate::engine::EnvInstance`
  --> /Users/aimeez/.cargo/registry/src/github.com-1ecc6299db9ec823/ink_env-3.0.0-rc2/src/api.rs:29:9
   |
29 |         EnvInstance,
   |         ^^^^^^^^^^^
   |         |
   |         no `EnvInstance` in `engine`
   |         help: a similar name exists in the module: `OnInstance`
error: aborting due to 2 previous errors
For more information about this error, try `rustc --explain E0432`.
error: could not compile `ink_env`
To learn more, run the command again with --verbose.
warning: build failed, waiting for other jobs to finish...
error: build failed
#+end_src

Update the command and it works:

#+begin_src shell
$ cargo expand --no-default-features --target=wasm32-unknown-unknown

#![feature(prelude_import)]
#![no_std]
#[prelude_import]
use core::prelude::v1::*;
#[macro_use]
extern crate core;
#[macro_use]
extern crate compiler_builtins;
use ink_lang as ink;
mod flipper {
    impl ::ink_lang::ContractEnv for Flipper {
        type Env = ::ink_env::DefaultEnvironment;
    }
    type Environment = <Flipper as ::ink_lang::ContractEnv>::Env;
    type AccountId =
        <<Flipper as ::ink_lang::ContractEnv>::Env as ::ink_env::Environment>::AccountId;
    type Balance = <<Flipper as ::ink_lang::ContractEnv>::Env as ::ink_env::Environment>::Balance;
    type Hash = <<Flipper as ::ink_lang::ContractEnv>::Env as ::ink_env::Environment>::Hash;
    type Timestamp =
        <<Flipper as ::ink_lang::ContractEnv>::Env as ::ink_env::Environment>::Timestamp;
    type BlockNumber =
        <<Flipper as ::ink_lang::ContractEnv>::Env as ::ink_env::Environment>::BlockNumber;
    #[cfg(not(feature = "ink-as-dependency"))]
    const _: () = {
        impl<'a> ::ink_lang::Env for &'a Flipper {
            type EnvAccess = ::ink_lang::EnvAccess<'a, <Flipper as ::ink_lang::ContractEnv>::Env>;
            fn env(self) -> Self::EnvAccess {
                Default::default()
            }
        }
        impl<'a> ::ink_lang::StaticEnv for Flipper {
            type EnvAccess =
                ::ink_lang::EnvAccess<'static, <Flipper as ::ink_lang::ContractEnv>::Env>;
            fn env() -> Self::EnvAccess {
                Default::default()
            }
        }
    };
    #[cfg(not(feature = "ink-as-dependency"))]
    /// Defines the storage of your contract.
    /// Add new fields to the below struct in order
    /// to add new static storage fields to your contract.
    pub struct Flipper {
        /// Stores a single `bool` value on the storage.
        value: bool,
    }
    const _: () = {
        impl ::ink_storage::traits::SpreadLayout for Flipper {
            #[allow(unused_comparisons)]
            const FOOTPRINT: u64 = [
                (0u64 + <bool as ::ink_storage::traits::SpreadLayout>::FOOTPRINT),
                0u64,
            ][((0u64 + <bool as ::ink_storage::traits::SpreadLayout>::FOOTPRINT) < 0u64) as usize];
            const REQUIRES_DEEP_CLEAN_UP: bool = (false
                || (false
                    || <bool as ::ink_storage::traits::SpreadLayout>::REQUIRES_DEEP_CLEAN_UP));
            fn pull_spread(__key_ptr: &mut ::ink_storage::traits::KeyPtr) -> Self {
                Flipper {
                    value: <bool as ::ink_storage::traits::SpreadLayout>::pull_spread(__key_ptr),
                }
            }
            fn push_spread(&self, __key_ptr: &mut ::ink_storage::traits::KeyPtr) {
                match self {
                    Flipper { value: __binding_0 } => {
                        ::ink_storage::traits::SpreadLayout::push_spread(__binding_0, __key_ptr);
                    }
                }
            }
            fn clear_spread(&self, __key_ptr: &mut ::ink_storage::traits::KeyPtr) {
                match self {
                    Flipper { value: __binding_0 } => {
                        ::ink_storage::traits::SpreadLayout::clear_spread(__binding_0, __key_ptr);
                    }
                }
            }
        }
    };
    #[cfg(not(feature = "ink-as-dependency"))]
    const _: () = {
        #[allow(unused_imports)]
        use ::ink_lang::{Env as _, StaticEnv as _};
    };
    #[cfg(not(test))]
    #[cfg(not(feature = "ink-as-dependency"))]

    #... 
    #more
#+end_src

*** 2020-11-17 ink!

**** Follow the docs

Start with
[[https://substrate.dev/substrate-contracts-workshop/#/0/introduction][substrate.dev/substrate-contracts-workshop]]

Install from the webpage's command, but build failed.

The existing issue in Cargo's repo:
https://github.com/rust-lang/cargo/issues/7169

Need to read Cargo book:
https://doc.rust-lang.org/nightly/cargo/commands/cargo-install.html

Keep following the doc: [[https://substrate.dev/substrate-contracts-workshop/#/0/running-a-substrate-node][Running a Canvas Node]].
Btw, I like the tutorials explain each file.
It's helpful to me.

#+begin_src shell
$ canvas --dev --tmp
2020-11-17 17:20:43  Running in --dev mode, RPC CORS has been disabled.    
2020-11-17 17:20:43  Canvas Node    
2020-11-17 17:20:43  ✌️  version 0.1.0-e189090-x86_64-macos    
2020-11-17 17:20:43  ❤️  by Canvas, 2020-2020    
2020-11-17 17:20:43  📋 Chain specification: Development    
2020-11-17 17:20:43  🏷 Node name: cute-example-7440    
2020-11-17 17:20:43  👤 Role: AUTHORITY    
2020-11-17 17:20:43  💾 Database: RocksDb at /var/folders/g5/hf7q78jn0vngnqtqj_3qfm6r0000gn/T/substratePetkPI/chains/dev/db    
2020-11-17 17:20:43  ⛓  Native runtime: canvas-8 (canvas-0.tx1.au1)    
2020-11-17 17:20:43  🔨 Initializing Genesis block/state (state: 0x1611…971f, header-hash: 0x575c…6d5f)    
2020-11-17 17:20:43  👴 Loading GRANDPA authority set from genesis on what appears to be first startup.    
2020-11-17 17:20:43  ⏱  Loaded block-time = 6000 milliseconds from genesis on first-launch    
2020-11-17 17:20:43  Using default protocol ID "sup" because none is configured in the chain specs    
2020-11-17 17:20:43  🏷 Local node identity is: 12D3KooWSLjj5cAsQ8EeBvSRrxbg8b9mTzvoZVf7SA5NzkDzSCFx    
2020-11-17 17:20:43  📦 Highest known block at #0    
2020-11-17 17:20:43  〽️ Prometheus server started at 127.0.0.1:9615    
2020-11-17 17:20:43  Listening for new connections on 127.0.0.1:9944.    
2020-11-17 17:20:48  🙌 Starting consensus session on top of parent 0x575c06528df3f98a10aa6ac8d6d7c8f1d0ca9738206c05dc96516b1bcb836d5f    
2020-11-17 17:20:48  🎁 Prepared block for proposing at 1 [hash: 0x8d82ffaef8eea6679896f4b8335a68771ab7add86a51959368030e6aad395e8a; parent_hash: 0x575c…6d5f; extrinsics (1): [0xdc0e…86a9]]    
2020-11-17 17:20:48  🔖 Pre-sealed block for proposal at 1. Hash now 0x4b4fa8e91ef020d0544796b1dc9c26c046662b6bae182be5fa5548f9818863b4, previously 0x8d82ffaef8eea6679896f4b8335a68771ab7add86a51959368030e6aad395e8a.    
2020-11-17 17:20:48  ✨ Imported #1 (0x4b4f…63b4)    
2020-11-17 17:20:48  💤 Idle (0 peers), best: #1 (0x4b4f…63b4), finalized #0 (0x575c…6d5f), ⬇ 0 ⬆ 0    
2020-11-17 17:20:53  💤 Idle (0 peers), best: #1 (0x4b4f…63b4), finalized #0 (0x575c…6d5f), ⬇ 0 ⬆ 0    
2020-11-17 17:20:54  🙌 Starting consensus session on top of parent 0x4b4fa8e91ef020d0544796b1dc9c26c046662b6bae182be5fa5548f9818863b4    
2020-11-17 17:20:54  🎁 Prepared block for proposing at 2 [hash: 0x42d318b1165e2217212499aad57c1d6c89637668fb5d02d482415ef8eaa9f4da; parent_hash: 0x4b4f…63b4; extrinsics (1): [0x029c…6c04]]    

#+end_src

**** Thoughts

My experience with Polkadot, Substrate, and ink so far is pleasant.
The documentation is up to date enough with detailed step by step
descriptions. I can follow along smoothly.

There are some things I couldn't figure out at the first moment.
I realized that mostly because I am not familiar with Rust language and 
its ecosystem. For example, if I know Cargo better, I would learn
to use ~cargo install~ and ~cargo build~ correctly with necessary arguments.

*** 2020-11-15 Start

**** Follow the GitHub repo

#+begin_src shell
$ WASM_BUILD_TOOLCHAIN=nightly-2020-10-05 cargo build --release
error: failed to run custom build command for `node-template-runtime v2.0.0 (/Users/aimeez/github/substrate-node-template/runtime)`

Caused by:
  process didn't exit successfully: `/Users/aimeez/github/substrate-node-template/target/release/build/node-template-runtime-329be64dd2778179/build-script-build` (exit code: 1)
  --- stderr
     Compiling wasm-build-runner-impl v1.0.0 (/Users/aimeez/github/substrate-node-template/target/release/wbuild-runner/node-template-runtime3117747485089870701)
      Finished release [optimized] target(s) in 0.54s
       Running `/Users/aimeez/github/substrate-node-template/target/release/wbuild-runner/node-template-runtime3117747485089870701/target/x86_64-apple-darwin/release/wasm-build-runner-impl`
  Rust nightly not installed, please install it!
warning: build failed, waiting for other jobs to finish...
error: build failed
#+end_src

**** Install =nightly-2020-10-05= and build again

#+begin_src shell
$ rustup toolchain install nightly-2020-10-05

$ WASM_BUILD_TOOLCHAIN=nightly-2020-10-05 cargo build --release

error: failed to run custom build command for `node-template-runtime v2.0.0 (/Users/aimeez/github/substrate-node-template/runtime)`

Caused by:
  process didn't exit successfully: `/Users/aimeez/github/substrate-node-template/target/release/build/node-template-runtime-329be64dd2778179/build-script-build` (exit code: 1)
  --- stderr
     Compiling wasm-build-runner-impl v1.0.0 (/Users/aimeez/github/substrate-node-template/target/release/wbuild-runner/node-template-runtime3117747485089870701)
      Finished release [optimized] target(s) in 0.39s
       Running `/Users/aimeez/github/substrate-node-template/target/release/wbuild-runner/node-template-runtime3117747485089870701/target/x86_64-apple-darwin/release/wasm-build-runner-impl`
  Rust WASM toolchain not installed, please install it!

  Further error information:
  ------------------------------------------------------------
     Compiling wasm-test v1.0.0 (/var/folders/g5/hf7q78jn0vngnqtqj_3qfm6r0000gn/T/.tmpWk51lL)
  error[E0463]: can't find crate for `std`
    |
    = note: the `wasm32-unknown-unknown` target may not be installed

  error: aborting due to previous error

  For more information about this error, try `rustc --explain E0463`.
  error: could not compile `wasm-test`

  To learn more, run the command again with --verbose.
  ------------------------------------------------------------

warning: build failed, waiting for other jobs to finish...
error: build failed
#+end_src

**** Set target: 

#+begin_src shell
$ rustup target add wasm32-unknown-unknown --toolchain nightly-2020-10-05

error: failed to run custom build command for `node-template-runtime v2.0.0 (/Users/aimeez/github/substrate-node-template/runtime)`

Caused by:
  process didn't exit successfully: `/Users/aimeez/github/substrate-node-template/target/release/build/node-template-runtime-329be64dd2778179/build-script-build` (exit code: 1)
  --- stdout
  Executing build command: "/Users/aimeez/.rustup/toolchains/nightly-x86_64-apple-darwin/bin/cargo" "rustc" "--target=wasm32-unknown-unknown" "--manifest-path=/Users/aimeez/github/substrate-node-template/target/release/wbuild/node-template-runtime/Cargo.toml" "--color=always" "--release"

  --- stderr
     Compiling wasm-build-runner-impl v1.0.0 (/Users/aimeez/github/substrate-node-template/target/release/wbuild-runner/node-template-runtime3117747485089870701)
      Finished release [optimized] target(s) in 0.45s
       Running `/Users/aimeez/github/substrate-node-template/target/release/wbuild-runner/node-template-runtime3117747485089870701/target/x86_64-apple-darwin/release/wasm-build-runner-impl`
     Compiling sp-arithmetic v2.0.0
     Compiling sp-runtime-interface v2.0.0
     Compiling parity-util-mem v0.7.0
  error[E0282]: type annotations needed
#+end_src

**** Built failed because my default setting is nightly but not stable.

#+begin_src shell
$ rustc -V
rustc 1.50.0-nightly (98d66340d 2020-11-14)

$ rustup default stable

info: using existing install for 'stable-x86_64-apple-darwin'
info: default toolchain set to 'stable-x86_64-apple-darwin'

  stable-x86_64-apple-darwin unchanged - rustc 1.47.0 (18bf6b4f0 2020-10-07)
#+end_src

**** It took 13 minutes to build: my laptop is slow...

#+begin_src shell
$ WASM_BUILD_TOOLCHAIN=nightly-2020-10-05 cargo build --release

Finished release [optimized] target(s) in 13m 17s
#+end_src

**** Cute run!

#+begin_src shell
$ ./target/release/node-template --dev --tmp
Nov 15 18:04:40.702  WARN Running in --dev mode, RPC CORS has been disabled.    
Nov 15 18:04:40.703  INFO Substrate Node    
Nov 15 18:04:40.703  INFO ✌️  version 2.0.0-24da767-x86_64-macos    
Nov 15 18:04:40.703  INFO ❤️  by Substrate DevHub <https://github.com/substrate-developer-hub>, 2017-2020    
Nov 15 18:04:40.703  INFO 📋 Chain specification: Development    
Nov 15 18:04:40.703  INFO 🏷  Node name: super-top-6271    
Nov 15 18:04:40.703  INFO 👤 Role: AUTHORITY    
Nov 15 18:04:40.703  INFO 💾 Database: RocksDb at /var/folders/g5/hf7q78jn0vngnqtqj_3qfm6r0000gn/T/substrate2jvpo0/chains/dev/db    
Nov 15 18:04:40.703  INFO ⛓  Native runtime: node-template-1 (node-template-1.tx1.au1)    
Nov 15 18:04:40.755  INFO 🔨 Initializing Genesis block/state (state: 0xc29a…9e07, header-hash: 0x40ca…fc14)    
Nov 15 18:04:40.756  INFO 👴 Loading GRANDPA authority set from genesis on what appears to be first startup.    
Nov 15 18:04:40.774  INFO ⏱  Loaded block-time = 6000 milliseconds from genesis on first-launch    
Nov 15 18:04:40.774  WARN Using default protocol ID "sup" because none is configured in the chain specs    
Nov 15 18:04:40.774  INFO 🏷  Local node identity is: 12D3KooWSMTDCBT4GHADWJxdRJTBnSKgEAXrekDVcwG6SuQy1az9 (legacy representation: 12D3KooWSMTDCBT4GHADWJxdRJTBnSKgEAXrekDVcwG6SuQy1az9)    
Nov 15 18:04:41.071  INFO 📦 Highest known block at #0    
Nov 15 18:04:41.072  INFO 〽️ Prometheus server started at 127.0.0.1:9615    
Nov 15 18:04:41.073  INFO Listening for new connections on 127.0.0.1:9944.    
Nov 15 18:04:42.012  INFO 🙌 Starting consensus session on top of parent 0x40ca582052a890e826eb0c3d3e5d9a1383f7cb95dd87d5b542b574040ea6fc14    
Nov 15 18:04:42.017  INFO 🎁 Prepared block for proposing at 1 [hash: 0x384b4a0ce970b7b28dbc0764ef74ee3b3a55517c31476496db175845d03fe61e; parent_hash: 0x40ca…fc14; extrinsics (1): [0xab8e…deca]]    
Nov 15 18:04:42.021  INFO 🔖 Pre-sealed block for proposal at 1. Hash now 0x753af28ba42e197ddf1df41477d452ac35cd3138afe70083f81e64637f51c1fd, previously 0x384b4a0ce970b7b28dbc0764ef74ee3b3a55517c31476496db175845d03fe61e.    
Nov 15 18:04:42.021  INFO ✨ Imported #1 (0x753a…c1fd)    
Nov 15 18:04:46.074  INFO 💤 Idle (0 peers), best: #1 (0x753a…c1fd), finalized #0 (0x40ca…fc14), ⬇ 0 ⬆ 0    
Nov 15 18:04:48.010  INFO 🙌 Starting consensus session on top of parent 0x753af28ba42e197ddf1df41477d452ac35cd3138afe70083f81e64637f51c1fd    
Nov 15 18:04:48.010  INFO 🎁 Prepared block for proposing at 2 [hash: 0x625c206bc45416b3745d544d93626a4cacaf74bf73c33cd11077edbeaaa95750; parent_hash: 0x753a…c1fd; extrinsics (1): [0xb6e9…2b6d]]    
Nov 15 18:04:48.014  INFO 🔖 Pre-sealed block for proposal at 2. Hash now 0xe680ef911bd8a4c24ea2d7485255ca2cbe275cd51d0fa71dcc29846f84524d38, previously 0x625c206bc45416b3745d544d93626a4cacaf74bf73c33cd11077edbeaaa95750.    
Nov 15 18:04:48.014  INFO ✨ Imported #2 (0xe680…4d38)    
#+end_src

**** Doc

https://substrate.dev/docs/en/tutorials/create-your-first-substrate-chain/interact
** Cheatsheet                            :hacking:git:emacs:orgmode:@hacking:
:PROPERTIES:
:EXPORT_FILE_NAME: cheatsheet
:EXPORT_DATE: 2020-10-29
:EXPORT_HUGO_SECTION: hacking
:EXPORT_DESCRIPTION: My cheatsheet about Git and Emacs.
:EXPORT_OPTIONS: toc:2
:END:

*** Emacs & org-mode
**** References

- https://stackoverflow.com/questions/16186843/inline-code-in-org-mode
- https://orgmode.org/org.html#Emphasis-and-monospace

**** Examples

src_sh[:exports code]{echo -e "test"}

#+begin_src 
src_sh[:exports code]{echo -e "test"}
#+end_Src

~fn main()~ 

#+begin_src
~fn main()~ 
#+end_src

=verbatim text=

#+begin_src
=verbatim text=
#+end_src

*** Git commands

**** Remote .git

#+begin_src shell
$ ls .git
$ rm .git
rm: .git: is a directory
$ rm -rf .git
#+end_src

**** Download a file from command line

#+begin_src shell
$ curl -LO https://upload.wikimedia.org/wikipedia/commons/c/c4/Creative-Tail-Halloween-ghost.svg
$ curl -L https://upload.wikimedia.org/wikipedia/commons/7/74/Twemoji2_1f47b.svg > ghost.svg
#+end_src

**** Cherry pick

#+begin_src shell
$ git remote add some_github_id https://github.com/some_github_id/rust-in-blockchain.git
$ git fetch some_github_id
$ git log some_github_id/master
$ git cherry-pick some_commit_hash
$ git diff HEAD^..HEAD
$ git push origin master
#+end_src

**** Reset a commit

#+begin_src shell
$ git reset HEAD^
$ git rm */~
$ git rm */*~
$ git commit --amend
$ git log
commit ad8b178eb99e414f7eb298798acbe1317099cc1b (HEAD -> master)
#+end_src

More: [[https://git-scm.com/book/en/v2/Git-Tools-Rewriting-History][Git Tools - Rewriting History]]

**** Hide changes and do not commit

#+begin_src shell
$ git stash
#+end_src

**** Cancel hiding

#+begin_src shell
$ git stash pop 
#+end_src

**** Add submodule to rib

#+begin_src shell
$ ln -> means link
#+end_src

**** Creat an aliase for syncing file 

#+begin_src shell
$ ln -s ../awesome-blockchain-rust/README.md awesome-blockchain-rust.md 
#+end_src

**** Recover to previous clean code

#+begin_src shell
$ git checkout -f
#+end_src

**** About PATH

#+begin_src shell
$ pwd
$ echo $PWD
$ export PATH=$PATH:$PWD
#+end_src

**** SSH

#+begin_src shell
$ eval `ssh-agent`
$ ssh-add
$ ssh -T git@github.com 
#+end_src

**** Generated a new key

#+begin_src shell
$ ssh-keygen -C your@email.com 
#+end_src

**** Move a file to current

#+begin_src shell
$ git mv www/contracts .
#+end_src
** Rust Cargo and More               :hacking:rust:cargo:rustup:log:@hacking:
:PROPERTIES:
:EXPORT_FILE_NAME: rust-cargo-etc
:EXPORT_DATE: 2020-11-14
:EXPORT_HUGO_SECTION: hacking
:EXPORT_DESCRIPTION: Understand Rust programming language.
:EXPORT_OPTIONS: toc:2
:END:

*** Cargo bin

#+begin_src shell
$ ~/.cargo/bin
-bash: /Users/aimeez/.cargo/bin: is a directory

$ cd ~/.cargo/bin
$ ls
basic-http-server	cargo-generate		diesel			rust-trending		ssmanager
cargo			cargo-make		lighthouse		rustc			ssserver
cargo-add		cargo-miri		makers			rustdoc			ssurl
cargo-casperlabs	cargo-rm		mdbook			rustfmt			wasm-pack
cargo-clippy		cargo-upgrade		mdbook-linkcheck	rustlings		wasm-pack.stamp
cargo-contract		cargo-watch		rls			rustup
cargo-fmt		cargo-web		rust-gdb		simple-http-server
cargo-fuzz		clippy-driver		rust-lldb		sslocal

$ which cargo
/Users/aimeez/.cargo/bin/cargo

$ ls -lh
total 496760
-rwxr-xr-x   1 aimeez  staff   5.1M Apr 26  2020 basic-http-server
-rwxr-xr-x  12 aimeez  staff   7.1M Jul 27 16:47 cargo
-rwxr-xr-x   1 aimeez  staff   7.1M Sep 14 10:48 cargo-add
-rwxr-xr-x   1 aimeez  staff   1.0M Aug 25 13:56 cargo-casperlabs
-rwxr-xr-x  12 aimeez  staff   7.1M Jul 27 16:47 cargo-clippy
-rwxr-xr-x   1 aimeez  staff   4.6M Nov  6 20:59 cargo-contract
-rwxr-xr-x  12 aimeez  staff   7.1M Jul 27 16:47 cargo-fmt
-rwxr-xr-x   1 aimeez  staff   1.3M May 18 18:52 cargo-fuzz
-rwxr-xr-x   1 aimeez  staff   6.5M Oct 14 14:37 cargo-generate
-rwxr-xr-x   1 aimeez  staff   7.9M Oct 29 13:17 cargo-make
-rwxr-xr-x  12 aimeez  staff   7.1M Jul 27 16:47 cargo-miri
-rwxr-xr-x   1 aimeez  staff   2.0M Sep 14 10:48 cargo-rm
-rwxr-xr-x   1 aimeez  staff   3.5M Sep 14 10:48 cargo-upgrade
-rwxr-xr-x   1 aimeez  staff   2.1M Aug 11 15:20 cargo-watch
-rwxr-xr-x   1 aimeez  staff   9.5M Oct 29 14:52 cargo-web
-rwxr-xr-x  12 aimeez  staff   7.1M Jul 27 16:47 clippy-driver
-rwxr-xr-x   1 aimeez  staff   3.1M Jun 17 12:56 diesel
-rwxr-xr-x   1 aimeez  staff    42M Aug 11 12:46 lighthouse
-rwxr-xr-x   1 aimeez  staff   7.9M Oct 29 13:17 makers
-rwxr-xr-x   1 aimeez  staff    10M Sep 20 11:06 mdbook
-rwxr-xr-x   1 aimeez  staff   9.3M Sep 20 11:09 mdbook-linkcheck
-rwxr-xr-x  12 aimeez  staff   7.1M Jul 27 16:47 rls
-rwxr-xr-x  12 aimeez  staff   7.1M Jul 27 16:47 rust-gdb
-rwxr-xr-x  12 aimeez  staff   7.1M Jul 27 16:47 rust-lldb
-rwxr-xr-x   1 aimeez  staff   6.5M Jun 13 15:51 rust-trending
-rwxr-xr-x  12 aimeez  staff   7.1M Jul 27 16:47 rustc
-rwxr-xr-x  12 aimeez  staff   7.1M Jul 27 16:47 rustdoc
-rwxr-xr-x  12 aimeez  staff   7.1M Jul 27 16:47 rustfmt
-rwxr-xr-x   1 aimeez  staff   2.7M Jul 27 16:43 rustlings
-rwxr-xr-x  12 aimeez  staff   7.1M Jul 27 16:47 rustup
-rwxr-xr-x   1 aimeez  staff   2.6M Aug 11 15:12 simple-http-server
-rwxr-xr-x   1 aimeez  staff   6.1M Jun  8 11:05 sslocal
-rwxr-xr-x   1 aimeez  staff   4.1M Jun  8 11:04 ssmanager
-rwxr-xr-x   1 aimeez  staff   3.9M Jun  8 11:04 ssserver
-rwxr-xr-x   1 aimeez  staff   1.3M Jun  8 11:03 ssurl
-rwxr-xr-x   1 aimeez  staff   7.2M May 23 01:28 wasm-pack
-rw-r--r--   1 aimeez  staff    54B Oct 29 14:21 wasm-pack.stamp
#+end_src

*** Rustup toolchains

[[https://rust-lang.github.io/rustup/installation/index.html][The rustup book]]
>rustup installs rustc, cargo, rustup and other standard tools 
to Cargo's bin directory. On Unix it is located at $HOME/.cargo/bin 
and on Windows at %USERPROFILE%\.cargo\bin. 
This is the same directory that cargo install will 
install Rust programs and Cargo plugins.


Toolchains on my mac:

#+begin_src shell
$ ls ~/.rustup/
downloads	settings.toml	toolchains	update-hashes

$ ls ~/.rustup/toolchains/
1.34.2-x86_64-apple-darwin		nightly-2019-10-14-x86_64-apple-darwin	nightly-x86_64-apple-darwin
1.41.0-x86_64-apple-darwin		nightly-2020-03-19-x86_64-apple-darwin	stable-x86_64-apple-darwin
1.43.1-x86_64-apple-darwin		nightly-2020-05-15-x86_64-apple-darwin
1.45.2-x86_64-apple-darwin		nightly-2020-08-23-x86_64-apple-darwin

$ ls ~/.rustup/toolchains/stable-x86_64-apple-darwin/
bin	etc	lib	share

$ ls ~/.rustup/toolchains/stable-x86_64-apple-darwin/bin/
cargo		cargo-fmt	rls		rust-gdbgui	rustc		rustfmt
cargo-clippy	clippy-driver	rust-gdb	rust-lldb	rustdoc
#+end_src
*** Rust lang entry

[[https://github.com/rust-lang/rust/blob/efbaa413061c2a6e52f06f00a60ee7830fcf3ea5/compiler/rustc_passes/src/entry.rs#L50-L76][EntryPointType]]

[[https://github.com/rust-lang/rust/blob/56293097f7f877f1350a6cd00f79d03132f16515/compiler/rustc_codegen_cranelift/src/main_shim.rs][rust/compiler/rustc_codegen_cranelift/src/main_shim.rs]]

Rustc: #[lang = "start"]

[[https://github.com/rust-lang/rust/blob/master/library/std/src/rt.rs#L60][fn lang_start<T: crate::process::Termination + 'static>(main: fn() -> T, argc: isize, argv: *const *const u8,)]]

Rustc uses std to create the main() function,
with mymain() as one argument,
as lang-start for the operating system 
to start executing.

From [[https://play.rust-lang.org/][Rust playground]], we can generate LLVM code from 
our empty main function:

#+begin_src rust
fn main() {
}
#+end_src

The LLVM code:

#+begin_src llvm
; std::rt::lang_start
; Function Attrs: nonlazybind uwtable
define hidden i64 @_ZN3std2rt10lang_start17hd0d6144126b78ac1E(void ()* nonnull %main, i64 %argc, i8** %argv) unnamed_addr #1 !dbg !42 {
start:
#+end_src

** Rust Smart Contract               :blockchain:rust:smartcontract:@hacking:
:PROPERTIES:
:EXPORT_FILE_NAME: rust-smart-contract
:EXPORT_DATE: 2020-11-21
:EXPORT_HUGO_SECTION: hacking
:EXPORT_DESCRIPTION: Learning resources and references.
:EXPORT_OPTIONS: toc:2
:END:

[[https://github.com/brson/rust-contract-comparison][rust-contract-comparison]]

[[http://troubles.md/why-write-smart-contracts-in-rust/][Why Write Smart Contracts in Rust?]]
> The future of smart contracts, in my eyes 
and the eyes of many others, lies with WebAssembly. 
This is a virtual machine specification 
which essentially acts as a portable and simple RISC ISA - since 
it matches the runtime model of 
a CPU many existing languages can be compiled to it unchanged. 
Apart from special-case DSLs like Solidity most languages 
expose the runtime model of the CPU somehow. 
Not only that, but its similarity to the CPU allows 
it to be compiled to incredibly efficient machine code 
without complex optimisations that can affect correctness 
and increase code complexity.

[[https://github.com/paritytech/fleetwood][Fleetwood]]
> *Future Work*
> 
> It would be nice to be able to write smart contracts 
that are easily compiled for different chains 
with no runtime overhead while allowing to use 
specific details of the underlying chain. 
While developing the Fleetwood technology stack 
we are trying to uphold this future goal 
by considering interoperability of new features in accordance to it.

** Rust and Computer Science                               :rust:cs:@hacking:
:PROPERTIES:
:EXPORT_FILE_NAME: rust-cs
:EXPORT_DATE: 2020-11-21
:EXPORT_HUGO_SECTION: hacking
:EXPORT_DESCRIPTION: Rust and CS resources.
:EXPORT_OPTIONS: toc:2
:END:

*** CS

[[https://reberhardt.com/cs110l/spring-2020/][CS 110L: Safety in Systems Programming]]
- [[https://reberhardt.com/cs110l/spring-2020/slides/lecture-18.pdf][Comparison between C and Rust]]

[[https://github.com/cis198-2016s][CIS 198 - Rust - Spring 2016]]
- [[https://cis198-2016s.github.io/projects/][Project page]]

[[https://github.com/SmallPond/MIT6.828_OS][MIT6.828 Operating System Engineering]]

Type system
- [[https://v5.chriskrycho.com/journal/things-i-was-wrong-about/1-types/][Things I Was Wrong About: Types]]

[[https://www.cs.utexas.edu/~EWD/transcriptions/EWD03xx/EWD340.html][The Humble Programmer by Edsger W. Dijkstra]]


[[https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-10.html][1.1  The Elements of Programming]]
> **Primitive expressions**, which represent the simplest entities the language is concerned with,
>
> **Means of combination**, by which compound elements are built from simpler ones, and
>
> **means of abstraction**, by which compound elements can be named and manipulated as units

*** Rust language

[[https://people.mpi-sws.org/~jung/phd/thesis-screen.pdf][Understanding and Evolving the Rust Programming Language]] August 2020

[[https://wiki.alopex.li/RustStarterKit2020][Rust Starter Kit 2020]]

Video: [[https://www.youtube.com/watch?v=0zOg8_B71gE][Pascal Hertleif - Writing Idiomatic Libraries in Rust]]

*** Rust discussion

[[https://readrust.net/computer-science][ReadRust: Computer Science]]

[[https://www.reddit.com/r/rust/comments/6nw22d/opinions_about_using_rust_instead_of_c_in/][Reddit discussion: Opinions about using Rust instead of C in Computer Science courses]]

Rust weaknesses:
[[https://www.reddit.com/r/rust/comments/jia2xn/what_are_some_of_rusts_weaknesses_as_a_language/][This question got a bunch of discussions]]


** Error Handling                               :rust:errorhandling:@hacking:
:PROPERTIES:
:EXPORT_FILE_NAME: error-handling
:EXPORT_DATE: 2020-11-21
:EXPORT_HUGO_SECTION: hacking
:EXPORT_DESCRIPTION: Error handling learning and practice.
:EXPORT_OPTIONS: toc:2
:END:

*** std::io::Error

- [[https://github.com/rust-bitcoin/rust-bitcoin/pull/494#issuecomment-716196725][rust-bitcoin discussion]]
- He also linked to his commemt on reddit:
  [[https://www.reddit.com/r/rust/comments/jbdk5x/blog_post_study_of_stdioerror/g8vzhjy/?utm_source=reddit&utm_medium=web2x&context=3][std::io::Error]]
  for which he commented to matklad's blog post 
  [[https://matklad.github.io/2020/10/15/study-of-std-io-error.html][study of std::io::Error]]

*** anyhow::Result



** Game Theory       :blockchain:community:incentives:gametheory:@blockchain:
:PROPERTIES:
:EXPORT_FILE_NAME: game-theory
:EXPORT_DATE: 2020-11-24
:EXPORT_HUGO_SECTION: blockchain
:EXPORT_DESCRIPTION: Game theory, blockchain protocols, etc.
:EXPORT_OPTIONS: toc:2
:END:


*** Learning

[[https://www.youtube.com/watch?v=WyRyWQwm0x0][An Axiomatic Approach to Block Rewards (Tim Roughgarden @ Stanford Blockchain Conference 2020)]]
> *Strategy:*
> - articulate desiderata of allocation rules
> - prove that the proportional rule the unique
    one satisfying all of them
>
> *Role models:* von Neumann-Morgenstern Utility Theory,
  Arrow/s Impossibility Theorem, the Shapley value.
>
> *Note:* impossibility/uniqueness results clarify
  the compromises required.

[[https://arxiv.org/pdf/1909.10645.pdf][An Axiomatic Approach to Block Rewards]]




** Blockchain Voting                          :blockchain:voting:@blockchain:
:PROPERTIES:
:EXPORT_FILE_NAME: blockchain-voting
:EXPORT_DATE: 2020-11-16
:EXPORT_HUGO_SECTION: blockchain
:EXPORT_DESCRIPTION: Reading notes about blockchain voting.
:EXPORT_OPTIONS: toc:2
:END:

*** Posts

[[https://www.schneier.com/blog/archives/2019/02/blockchain_and_.html][Blockchain and Trust]], 2019
> When you analyze both blockchain and trust, you quickly realize that 
there is much more hype than value. Blockchain solutions are 
often much worse than what they replace.
>
> First, a caveat. By blockchain, I mean something very specific: 
the data structures and protocols that make up a public blockchain. 
These have three essential elements. The first is a distributed 
(as in multiple copies) but centralized (as in there’s only one) ledger, 
which is a way of recording what happened and in what order. 
This ledger is public, meaning that anyone can read it, and immutable, 
meaning that no one can change what happened in the past.
>
> The second element is the consensus algorithm, which is a way 
to ensure all the copies of the ledger are the same. This is 
generally called mining; a critical part of the system is that 
anyone can participate. It is also distributed, meaning that 
you don’t have to trust any particular node in the consensus network. 
It can also be extremely expensive, both in data storage and 
in the energy required to maintain it. Bitcoin has the most expensive 
consensus algorithm the world has ever seen, by far.
>
> Finally, the third element is the currency. This is some sort of 
digital token that has value and is publicly traded. Currency is 
a necessary element of a blockchain to align the incentives of 
everyone involved. Transactions involving these tokens are stored on the ledger.
>
> Most blockchain enthusiasts have a unnaturally narrow definition of trust. 
They’re fond of catchphrases like “[[https://www.nytimes.com/2017/12/18/opinion/bitcoin-boom-technology-trust.html][in code we trust]],” “[[https://www.amazon.com/Math-We-Trust-Bitcoin-Cryptocurrency-ebook/dp/B07C7TPXMD?tag=w050b-20][in math we trust]],” 
and “[[https://cryptoclothing.org/product/crypto-shirt/][in crypto we trust]].” This is trust as verification. 
But verification isn’t the same as trust.

> Morals and reputation scale only to a certain population size. 
Primitive systems were good enough for small communities, 
but larger communities required delegation, and more formalism.
>
> The third is institutions. Institutions have rules and laws that 
induce people to behave according to the group norm, 
imposing sanctions on those who do not. In a sense, 
laws formalize reputation. Finally, the fourth is security systems. 
These are the wide varieties of security technologies we employ: 
door locks and tall fences, alarm systems and guards, 
forensics and audit systems, and so on.
>
> These four elements work together to enable trust. 

> In many ways, trusting technology is harder than trusting people. 
Would you rather trust a human legal system or the details of 
some computer code you don’t have the expertise to audit?


*** Papers

[[https://people.csail.mit.edu/rivest/pubs/PSNR20.pdf][Going from Bad to Worse: From Internet Voting to Blockchain Voting]], November 6, 2020 (DRAFT)

** DAO                                           :blockchain:dao:@blockchain:
:PROPERTIES:
:EXPORT_FILE_NAME: dao
:EXPORT_DATE: 2020-11-16
:EXPORT_HUGO_SECTION: blockchain
:EXPORT_DESCRIPTION: Reading notes about the community DAO.
:EXPORT_OPTIONS: toc:2
:END:

[[https://blog.ethereum.org/2014/12/26/secret-sharing-daos-crypto-2-0/][Secret Sharing DAOs: The Other Crypto 2.0]], 2014

[[https://github.com/DavidJohnstonCEO/DecentralizedApplications][The General Theory of Decentralized Applications, Dapps]]
> The concept of a Dapp is so powerful and elegant, because it does not 
include these traditional corporate techniques. The ownership of 
the Dapp’s tokens is all that is required for the holder to use the system. 
It’s that simple. The value of the tokens is determined by 
how much people value the application. All the incentives, 
all the monetization, all the ways to raise support are 
built into this beautifully simple structure. 
Dapps are not required to recreate the functions that used to be necessary 
in centralized corporations in order to balance the power of shareholders 
and offer returns for investors and employees.

> Initial tokens are distributed
>
> If the Dapp is using the fund-raising mechanism, a wallet software becomes 
available to the stakeholders of the Dapp, so that they can exchange 
the tokens of the DA. In the case of Mastercoin, an Exodus fund-raising address 
and a wallet script were publicly released.
>
> If the Dapp is using the development mechanism, a bounty system is 
put in place that allows the suggestion of tasks to be performed, 
the tracking of the people who are working on those tasks and 
the criteria by which bounties can be awarded.


[[https://bitcoinmagazine.com/articles/bootstrapping-a-decentralized-autonomous-corporation-part-i-1379644274][Bootstrapping A Decentralized Autonomous Corporation: Part I]] | 2013
> As Let’s Talk Bitcoin’s Daniel Larmier pointed out in his own exploration on this concept, 
in a sense Bitcoin itself can be thought of as a very early prototype of exactly such a thing. 
Bitcoin has 21 million shares, and these shares are owned by what can be considered 
Bitcoin’s shareholders. It has employees, and it has a protocol for paying them: 25 BTC 
to one random member of the workforce roughly every ten minutes. It even has 
its own marketing department, to a large extent made up of the shareholders themselves. 
However, it is also very limited. It knows almost nothing about the world except for 
the current time, it has no way of changing any aspect of its function aside from 
the difficulty, and it does not actually do anything per se; it simply exists, 
and leaves it up to the world to recognize it. The question is: can we do better?

> The first challenge is obvious: how would such a corporation actually make 
any decisions? It’s easy to write code that, at least given predictable environments, 
takes a given input and calculates a desired action to take. But who is going to 
run the code? If the code simply exists as a computer program on some particular machine, 
what is stopping the owner of that machine from shutting the whole thing down, 
or even modifying its code to make it send all of its money to himself? To this problem, 
there is only one effective answer: distributed computing.

> Here, rather, we need the kind of distributed computing that we see in Bitcoin: 
a set of rules that decentrally self-validates its own computation. 
In Bitcoin, this is accomplished by a simple majority vote: if you are not helping to 
compute the blockchain with the majority network power, your blocks will get discarded 
and you will get no block reward. The theory is that no single attacker will 
have enough computer power to subvert this mechanism, so the only viable strategy 
is essentially to “go with the flow” and act honestly to help support the network 
and receive one’s block reward. So can we simply apply this mechanism to 
decentralized computation? That is, can we simply ask every computer in the network to 
evaluate a program, and then reward only those whose answer matches the majority vote? 

> Bitcoin is a special case because Bitcoin is simple: it is just a currency, 
carrying no property or private data of its own. A virtual corporation, 
on the other hand, would likely need to store the private key to its Bitcoin wallet – 
a piece of data which should be available in its entirety to no one, not to everyone 
in the way that Bitcoin transactions are. But, of course, the private key must 
still be usable. Thus, what we need is some system of signing transactions, 
and even generating Bitcoin addresses, that can be computed in a decentralized way. 
Fortunately, Bitcoin allows us to do exactly that.

[[https://blog.ethereum.org/2014/05/06/daos-dacs-das-and-more-an-incomplete-terminology-guide/][
DAOs, DACs, DAs and More: An Incomplete Terminology Guide]] | 2014
> as Bitshares’ Daniel Larimer points out, “everyone thinks a DAC is just a way of 
IPOing your centralized company.” The intent of this article will be to delve into 
some of these concepts, and see if we can come up with at least the beginnings of 
a coherent understanding of what all of these things actually are.

> Note that there is one gray area here: contracts which are finite on one side, 
but infinite on the other side. For example, if I want to hedge the value of 
my digital assets, I might want to create a contract where anyone can 
freely enter and leave. Hence, the other side of the contract, the parties 
that are speculating on the asset at 2x leverage, has an unbounded number of parties, 
but my side of the contract does not. Here, I propose the following divide: 
if the side with a bounded number of parties is the side that intends to receive 
a specific service (ie. is a consumer), then it is a smart contract; however, 
if the side with a bounded number of parties is just in it for profit 
(ie. is a producer), then it is not.

> That is, there is a concept of shares in a DAC which are purchaseable 
and tradeable in some fashion, and those shares potentially entitle 
their holders to continual receipts based on the DAC’s success. 
A DAO is non-profit; though you can make money in a DAO, the way to do 
that is by participating in its ecosystem and not by providing investment 
into the DAO itself. Obviously, this distinction is a murky one; 
all DAOs contain internal capital that can be owned, and the value of 
that internal capital can easily go up as the DAO becomes more powerful/popular, 
so a large portion of DAOs are inevitably going to be DAC-like to some extent.
>
> Thus, the distinction is more of a fluid one and hinges on emphasis: 
to what extent are dividends the main point, and to what extent is it about 
earning tokens by participation? Also, to what extent does the concept of 
a “share” exist as opposed to simple virtual property? For example, 
a membership on a nonprofit board is not really a share, because membership 
frequently gets granted and confiscated at will, something which would be 
unacceptable for something classified as investable property, and a bitcoin is not 
a share because a bitcoin does not entitle you to any claim on profits or 
decision-making ability inside the system, whereas a share in a corporation 
definitely is a share. In the end, perhaps the distinction might ultimately be 
the surprisingly obscure point of whether or not the profit mechanism 
and the consensus mechanism are the same thing.

> Additionally, there is also the question of how all of these things should be built. 
An AI, for example, should likely exist as a network of private servers, 
each one running often proprietary local code, whereas a DO should be fully 
open source and blockchain-based. Between those two extremes, there is 
a large number of different paradigms to pursue. How much of the intelligence 
should be in the core code? Should genetic algorithms be used for updating code, 
or should it be futarchy or some voting or vetting mechanism based on individuals? 
Should membership be corporate-style, with sellable and transferable shares, 
or nonprofit-style, where members can vote other members in and out? 
Should blockchains be proof of work, proof of stake, or reputation-based? 
Should DAOs try to maintain balances in other currencies, 
or should they only reward behavior by issuing their own internal token? 
These are all hard problems and we have only just begun scratching the surface of them.

[[https://hackernoon.com/turn-an-internet-community-into-a-dao-in-3-steps-8k1b3w5y][Turn an Internet Community into a DAO in 3 Steps]]
> Simply put, DAO is a perfect structure to organize collective activities in the community, 
especially when most collaborations in the community are conducted distributedly, 
multi-disciplinarily, in random occurrence, and without a trust basis. 
DAO leverages Smart Contract on the blockchain to automatically implement contract terms 
to solve the trust issues. Also, contribution-based incentives can be allocated to activate the community.
>
> However, DAO's structure is not perfect and has some limitations for large scale applications.
>
> First, DAO relies too much on the smart contract, while the machine language is not suitable 
for conveying complex business logic. It's almost impossible for a general internet community 
to become an expert to compile all its collaboration needs into the contract. 
The stake is too high! It is also costly and low in efficiency if every operation step 
needs to run smart contracts on the blockchain to reach the global consensus. 
>
> Second, most of DAO's governance protocols mainly focus on the voting algorithm, 
while for the internet communities, voting would only be a small part of 
all the collective actions. Actually, the community is more caring about how to 
make the collaborations happen among all the community members.
>
> Third, as there is a lack of an effective management system to regulate 
the collaborations, the DAO has become only a shell structure without any real value 
creation activities in it. So, it's not hard to understand that the DAO's 
governance token holders have low intent to vote as they do not care about 
what is going on in the community, and they are only pursuing arbitrage opportunities.  

> The Wiki-based ComCo Management Framework contains one's collaboration history, 
which can be traced back as the credential check.

**

** Governance                               :community:governance:@community:
:PROPERTIES:
:EXPORT_FILE_NAME: governance
:EXPORT_DATE: 2020-11-12
:EXPORT_HUGO_SECTION: community
:EXPORT_OPTIONS: toc:2
:END:

#+begin_description
Notes about governance in open source communities,
including developer communities and blockchain projects' communities.
#+end_description

[[https://www.djangoproject.com/weblog/2020/mar/12/governance/][New governance model for the Django project]]
- James Bennett on March 12, 2020

[[https://github.com/django/deps/blob/master/accepted/0010-new-governance.rst][DEP 0010: New governance for the Django project]]
- Created:	2018-09-22
- Last-Modified:	2020-03-12

[[https://github.com/rust-lang/wg-governance/blob/master/CHARTER.md][Rust-lang: Governance WG Charter]]
- last updated: [May 25th 2019] 

[[https://ziglang.org/news/announcing-zig-software-foundation.html][Announcing the Zig Software Foundation]]
- Zig language

[[https://modelviewculture.com/pieces/codes-of-conduct-when-being-excellent-is-not-enough][Codes of Conduct: When Being Excellent is Not Enough]]
- December 10th, 2014

** Data Structures in Popular Blockchains  :hacking:blockchain:rust:@hacking:
:PROPERTIES:
:EXPORT_FILE_NAME: data-structures-in-popular-blockchains
:EXPORT_DATE: 2020-11-02
:EXPORT_HUGO_SECTION: hacking
:EXPORT_DESCRIPTION: Data structures in popular rust blockchains.
:EXPORT_OPTIONS: toc:2
:END:


Not as simple as I thought,
data structure are designed quite differently in different projects.

Let's take a look at some examples.

*** [[https://github.com/rust-bitcoin/rust-bitcoin][Bitcoin]]

[[https://en.bitcoin.it/wiki/Protocol_documentation#Block_Headers][Bitcoin Headers]]

[[https://en.bitcoin.it/wiki/Block_hashing_algorithm][Block hashing algorithm]]

>A block header contains these fields:
4  Bytes Version	       		Block version number
32 Bytes hashPrevBlock		256-bit hash of the previous block header
32 Bytes hashMerkleRoot		256-bit hash based on all of the transactions in the block
4 Bytes	 Time			Current block timestamp as seconds since 1970-01-01T00:00 UTC
4 Bytes	 Bits			Current target in compact format
4 Bytes	 Nonce			32-bit number (starts at 0)

[[https://docs.rs/bitcoin/0.25.0/bitcoin/][Rust Bitcoin Library]]

I started with the well-known example of Bitcoin.
Its protocol is simple and clearly explained in the whitepaper.

src: rust-bitcoin/src/blockdata/block.rs

I like developers put an introduction in front of a page!

#+begin_src rust
//! Bitcoin Block
//!
//! A block is a bundle of transactions with a proof-of-work attached,
//! which commits to an earlier block to form the blockchain. This
//! module describes structures and functions needed to describe
//! these blocks and the blockchain.
//!
#+end_src

A Bitcoin block data structure is simple,
and it looks like this:

#+begin_src rust
/// A Bitcoin block, which is a collection of transactions with an attached
/// proof of work.
#[derive(PartialEq, Eq, Clone, Debug)]
pub struct Block {
    /// The block header
    pub header: BlockHeader,
    /// List of transactions contained in the block
    pub txdata: Vec<Transaction>
}
#+end_src


And the blockheader:

#+begin_src rust
/// A block header, which contains all the block's information except
/// the actual transactions
#[derive(Copy, PartialEq, Eq, Clone, Debug)]
pub struct BlockHeader {
    /// The protocol version. Should always be 1.
    pub version: i32,
    /// Reference to the previous block in the chain
    pub prev_blockhash: BlockHash,
    /// The root hash of the merkle tree of transactions in the block
    pub merkle_root: TxMerkleNode,
    /// The timestamp of the block, as claimed by the miner
    pub time: u32,
    /// The target value below which the blockhash must lie, encoded as a
    /// a float (with well-defined rounding, of course)
    pub bits: u32,
    /// The nonce, selected to obtain a low enough blockhash
    pub nonce: u32,
}
#+end_src

In order to save disk space, Bitcoin uses Merkle tree to compress
transaction history.
[[https://en.wikipedia.org/wiki/Merkle_tree][Merkle tree]] is a binary hash tree.
The `merkle_root` in the `BlockHeader` struct refers to
the root of a Merkle tree,
which indicates the proof of transaction history.

[[https://bitcoin.org/bitcoin.pdf][Bitcoin Whitepaper]] is simple paper that explains
its architecture.

Then let's take a look at its value field, `txdata: Vec<Transaction>`.

#+begin_src rust
//! Bitcoin Transaction
//!
//! A transaction describes a transfer of money. It consumes previously-unspent
//! transaction outputs and produces new ones, satisfying the condition to spend
//! the old outputs (typically a digital signature with a specific key must be
//! provided) and defining the condition to spend the new ones. The use of digital
//! signatures ensures that coins cannot be spent by unauthorized parties.
//!
//! This module provides the structures and functions needed to support transactions.
//!
#+end_src

[[https://docs.rs/bitcoin/0.25.0/bitcoin/blockdata/transaction/struct.Transaction.html][Struct bitcoin::blockdata::transaction::Transaction]]

In Bitcoin, transactions issues started with
searching for recievers' addresses.
Then find the input UTXOs with approved signature.
So the input and output data structures are a bit different.

#+begin_src rust
/// A transaction output, which defines new coins to be created from old ones.
#[derive(Clone, PartialEq, Eq, Debug, Hash)]
pub struct TxOut {
    /// The value of the output, in satoshis
    pub value: u64,
    /// The script which must satisfy for the output to be spent
    pub script_pubkey: Script
}
#+end_src

#+begin_src rust
/// A transaction input, which defines old coins to be consumed
#[derive(Clone, PartialEq, Eq, Debug, Hash)]
pub struct TxIn {
    /// The reference to the previous output that is being used an an input
    pub previous_output: OutPoint,
    /// The script which pushes values on the stack which will cause
    /// the referenced output's script to accept
    pub script_sig: Script,
    /// The sequence number, which suggests to miners which of two
    /// conflicting transactions should be preferred, or 0xFFFFFFFF
    /// to ignore this feature. This is generally never used since
    /// the miner behaviour cannot be enforced.
    pub sequence: u32,
    /// Witness data: an array of byte-arrays.
    /// Note that this field is *not* (de)serialized with the rest of the TxIn in
    /// Encodable/Decodable, as it is (de)serialized at the end of the full
    /// Transaction. It *is* (de)serialized with the rest of the TxIn in other
    /// (de)serialization routines.
    pub witness: Vec<Vec<u8>>
}
#+end_src

*** [[https://github.com/openethereum/openethereum][Ethereum]]

OpenEthereum is Ethereum 1.0 Rust client.

Different from Bitcoin's data structure,
Ethereum introduces one more field.

src: openethereum/ethcore/types/src/block.rs

#+begin_src rust
/// A block, encoded as it is on the block chain.
#[derive(Default, Debug, Clone, PartialEq)]
pub struct Block {
	/// The header of this block.
	pub header: Header,
	/// The transactions in this block.
	pub transactions: Vec<UnverifiedTransaction>,
	/// The uncles of this block.
	pub uncles: Vec<Header>,
}
#+end_src

Its header data structure is much more complicated compared to Bitcoin.

src: openethereum/ethcore/types/src/header.rs

#+begin_src rust
/// A block header.
///
/// Reflects the specific RLP fields of a block in the chain with additional room for the seal
/// which is non-specific.
///
/// Doesn't do all that much on its own.
#[derive(Debug, Clone, Eq, MallocSizeOf)]
pub struct Header {
	/// Parent hash.
	parent_hash: H256,
	/// Block timestamp.
	timestamp: u64,
	/// Block number.
	number: BlockNumber,
	/// Block author.
	author: Address,

	/// Transactions root.
	transactions_root: H256,
	/// Block uncles hash.
	uncles_hash: H256,
	/// Block extra data.
	extra_data: Bytes,

	/// State root.
	state_root: H256,
	/// Block receipts root.
	receipts_root: H256,
	/// Block bloom.
	log_bloom: Bloom,
	/// Gas used for contracts execution.
	gas_used: U256,
	/// Block gas limit.
	gas_limit: U256,

	/// Block difficulty.
	difficulty: U256,
	/// Vector of post-RLP-encoded fields.
	seal: Vec<Bytes>,

	/// Memoized hash of that header and the seal.
	hash: Option<H256>,
}
#+end_src

I can't fully understand the header data structure
design just from the code.
I guess I need to reread [[https://ethereum.github.io/yellowpaper/paper.pdf][Ethereum Yellow Paper]].

src: openethereum/ethcore/types/src/transaction/transaction.rs

#+begin_src rust
/// A set of information describing an externally-originating message call
/// or contract creation operation.
#[derive(Default, Debug, Clone, PartialEq, Eq, MallocSizeOf)]
pub struct Transaction {
	/// Nonce.
	pub nonce: U256,
	/// Gas price.
	pub gas_price: U256,
	/// Gas paid up front for transaction execution.
	pub gas: U256,
	/// Action, can be either call or contract create.
	pub action: Action,
	/// Transfered value.
	pub value: U256,
	/// Transaction data.
	pub data: Bytes,
}
#+end_src

Yellow paper:
>The Transaction. A transaction (formally, T) is a
single cryptographically-signed instruction constructed by
an actor externally to the scope of Ethereum.
on1
>
>There are two types of transactions: those
which result in message calls and those which result in
the creation of new accounts with associated code (known
informally as ‘contract creation').

#+begin_src rust
/// Transaction action type.
#[derive(Debug, Clone, PartialEq, Eq, MallocSizeOf)]
pub enum Action {
	/// Create creates new contract.
	Create,
	/// Calls contract at given address.
	/// In the case of a transfer, this is the receiver's address.'
	Call(Address),
}
#+end_src

The "contract" in the code comments are referring to a "smart contract" 
on the Ethereum blockchain platform, which can be considered 
as backend service in traditional internet programming, 
and a dapp, which with the full name of "decentralized application", 
can be regarded as the frontend.

*** [[https://github.com/paritytech/polkadot][Polkadot]]

Polkadot is built on Substrate, a blockchain framework.
The Substrate doc has explainations of its [[https://substrate.dev/docs/en/knowledgebase/learn-substrate/extrinsics#block-structure][Block Structure]]
> A block in Substrate is composed of a header and 
  an array of extrinsics. The header contains a
  block height, parent hash, extrinsics root, state root, and digest. 

src: core-primitives/src/lib.rs

src: parachain/test-parachains/adder/src/lib.rs

#+begin_src rust
#[derive(Default, Clone, Hash, Eq, PartialEq, Encode, Decode)]
pub struct HeadData {
	/// Block number
	pub number: u64,
	/// parent block keccak256
	pub parent_hash: [u8; 32],
	/// hash of post-execution state.
	pub post_state: [u8; 32],
}
#+end_src 

#+begin_src rust
/// Block data for this parachain.
#[derive(Default, Clone, Encode, Decode)]
pub struct BlockData {
	/// State to begin from.
	pub state: u64,
	/// Amount to add (overflowing)
	pub add: u64,
}
#+end_src

#+begin_src rust
/// Execute a block body on top of given parent head, producing new parent head
/// if valid.
pub fn execute(
	parent_hash: [u8; 32],
	parent_head: HeadData,
	block_data: &BlockData,
) -> Result<HeadData, StateMismatch> {
	debug_assert_eq!(parent_hash, parent_head.hash());

	if hash_state(block_data.state) != parent_head.post_state {
		return Err(StateMismatch);
	}

	let new_state = block_data.state.overflowing_add(block_data.add).0;

	Ok(HeadData {
		number: parent_head.number + 1,
		parent_hash,
		post_state: hash_state(new_state),
	})
}
#+end_src

src: substrate/primitives/blockchain/src/header_metadata.rs

#+begin_src rust
/// Handles header metadata: hash, number, parent hash, etc.
pub trait HeaderMetadata<Block: BlockT> {
	/// Error used in case the header metadata is not found.
	type Error;

	fn header_metadata(
		&self,
		hash: Block::Hash,
	) -> Result<CachedHeaderMetadata<Block>, Self::Error>;
	fn insert_header_metadata(
		&self,
		hash: Block::Hash,
		header_metadata: CachedHeaderMetadata<Block>,
	);
	fn remove_header_metadata(&self, hash: Block::Hash);
}
#+end_src

src: substrate/primitives/blockchain/src/backend.rs

*** [[https://github.com/near/nearcore.git][NEAR]]

NEAR has two types of block structure that looks more or less the same.
I choose to use the "V2" version as the example code.

src: nearcore/core/primitives/src/block.rs

#+begin_src rust
#[derive(BorshSerialize, BorshDeserialize, Serialize, Debug, Clone, Eq, PartialEq)]
pub struct BlockV2 {
    pub header: BlockHeader,
    pub chunks: Vec<ShardChunkHeader>,
    pub challenges: Challenges,

    // Data to confirm the correctness of randomness beacon output
    pub vrf_value: near_crypto::vrf::Value,
    pub vrf_proof: near_crypto::vrf::Proof,
}
#+end_src

src: nearcore/core/primitives/src/block_header.rs

#+begin_src rust
/// Versioned BlockHeader data structure.
/// For each next version, document what are the changes between versions.
#[derive(BorshSerialize, BorshDeserialize, Serialize, Debug, Clone, Eq, PartialEq)]
pub enum BlockHeader {
    BlockHeaderV1(Box<BlockHeaderV1>),
    BlockHeaderV2(Box<BlockHeaderV2>),
}
#+end_src

Still, we choose to use V2 code.

#+begin_src rust
/// V1 -> V2: Remove `chunks_included` from `inner_reset`
#[derive(BorshSerialize, BorshDeserialize, Serialize, Debug, Clone, Eq, PartialEq)]
#[borsh_init(init)]
pub struct BlockHeaderV2 {
    pub prev_hash: CryptoHash,

    /// Inner part of the block header that gets hashed, split into two parts, one that is sent
    ///    to light clients, and the rest
    pub inner_lite: BlockHeaderInnerLite,
    pub inner_rest: BlockHeaderInnerRestV2,

    /// Signature of the block producer.
    pub signature: Signature,

    /// Cached value of hash for this block.
    #[borsh_skip]
    pub hash: CryptoHash,
}
#+end_src

src: nearcore/core/primitives/src/sharding.rs

#+begin_src rust
#[derive(BorshSerialize, BorshDeserialize, Serialize, Clone, PartialEq, Eq, Debug)]
#[borsh_init(init)]
pub struct ShardChunkHeaderV2 {
    pub inner: ShardChunkHeaderInner,

    pub height_included: BlockHeight,

    /// Signature of the chunk producer.
    pub signature: Signature,

    #[borsh_skip]
    pub hash: ChunkHash,
}
#+end_src

#+begin_src rust
#[derive(BorshSerialize, BorshDeserialize, Serialize, Clone, PartialEq, Eq, Debug)]
pub struct ShardChunkHeaderInner {
    /// Previous block hash.
    pub prev_block_hash: CryptoHash,
    pub prev_state_root: StateRoot,
    /// Root of the outcomes from execution transactions and results.
    pub outcome_root: CryptoHash,
    pub encoded_merkle_root: CryptoHash,
    pub encoded_length: u64,
    pub height_created: BlockHeight,
    /// Shard index.
    pub shard_id: ShardId,
    /// Gas used in this chunk.
    pub gas_used: Gas,
    /// Gas limit voted by validators.
    pub gas_limit: Gas,
    /// Total balance burnt in previous chunk
    pub balance_burnt: Balance,
    /// Outgoing receipts merkle root.
    pub outgoing_receipts_root: CryptoHash,
    /// Tx merkle root.
    pub tx_root: CryptoHash,
    /// Validator proposals.
    pub validator_proposals: Vec<ValidatorStake>,
}
#+end_src

src: nearcore/core/primitives/src/challenge.rs

#+begin_src rust
#[derive(BorshSerialize, BorshDeserialize, Serialize, PartialEq, Eq, Clone, Debug)]
#[borsh_init(init)]
pub struct Challenge {
    pub body: ChallengeBody,
    pub account_id: AccountId,
    pub signature: Signature,

    #[borsh_skip]
    pub hash: CryptoHash,
}

pub type Challenges = Vec<Challenge>;
#+end_src

Seems NEAR heavily typed their data.
I couldn't find NEAR's architecture design 
from its paper or documentation.

*** [[https://github.com/nervosnetwork/ckb][Nervos CKB]]

src: ckb/util/types/src/core/cell.rs

#+begin_src rust
#[derive(Clone, Eq, PartialEq, Default)]
pub struct CellMeta {
    pub cell_output: CellOutput,
    pub out_point: OutPoint,
    pub transaction_info: Option<TransactionInfo>,
    pub data_bytes: u64,
    /// In memory cell data and its hash
    /// A live cell either exists in memory or DB
    /// must check DB if this field is None
    pub mem_cell_data: Option<(Bytes, Byte32)>,
}
#+end_src

src: ckb/util/types/src/generated/blockchain.rs

#+begin_src rust
#[derive(Debug, Default)]
pub struct BlockBuilder {
    pub(crate) header: Header,
    pub(crate) uncles: UncleBlockVec,
    pub(crate) transactions: TransactionVec,
    pub(crate) proposals: ProposalShortIdVec,
}
#+end_src

#+begin_src rust
#[derive(Debug, Default)]
pub struct UncleBlockBuilder {
    pub(crate) header: Header,
    pub(crate) proposals: ProposalShortIdVec,
}
#+end_src 

There is almost no comment on these codes,
and I don't understand that `ProposalShortIdVec` means.
How they define `UncleBlockVec`, which raises 
new questions about "an uncle block". 
I hope there is a meaningful explanation here 
to eliminate the confusion of learning its code.

I finally found an [[https://github.com/nervosnetwork/rfcs/blob/master/rfcs/0019-data-structures/0019-data-structures.md][explaination of data structure]]
from its GitHub doc.
It would be much convenient if I could 
read this information in code comments.

In Bitcoin, the uncle block is stored in the header data;
In CKB, it is stored in the block directly as a field.
I don't have any further thoughts here at the moment.

After reading this page, I still don't know
what `ProposalShortIdVec` is.
I guess that might because I lack some pre-knowledge to start with.


src: ckb/util/types/src/core/cell.rs

#+begin_src rust
#[derive(Default)]
pub struct CellMetaBuilder {
    cell_output: CellOutput,
    out_point: OutPoint,
    transaction_info: Option<TransactionInfo>,
    data_bytes: u64,
    mem_cell_data: Option<(Bytes, Byte32)>,
}
#+end_src

src: ckb/util/types/src/core/transaction_meta.rs

#+begin_src rust
#[derive(Default, Debug, PartialEq, Eq, Clone)]
pub struct TransactionMeta {
    pub(crate) block_number: u64,
    pub(crate) epoch_number: u64,
    pub(crate) block_hash: Byte32,
    pub(crate) cellbase: bool,
    /// each bits indicate if transaction has dead cells
    pub(crate) dead_cell: BitVec,
}
#+end_src

src: ckb/util/types/src/core/blockchain.rs


*** More to do

- Solana
** Deal With Git Submodule in Hugo Themes :hacking:git:submodule:hugo:@hacking:
:PROPERTIES:
:EXPORT_FILE_NAME: git-submodule-hugo-theme
:EXPORT_DATE: 2020-10-31
:EXPORT_HUGO_SECTION: hacking
:EXPORT_DESCRIPTION: The problems I've met when I use Hugo themes, and how I solved it.
:EXPORT_OPTIONS: toc:2
:END:

I use hugo themes for this website, and I met problems.

*** Begin with Hugo and others' themes

I go inside the `themes` folder, and clone all three repos
followed the readme.

#+begin_src shell
$ cd themes/
$ git clone https://github.com/kaushalmodi/hugo-bare-min-theme.git
$ git clone https://github.com/kaushalmodi/hugo-search-fuse-js
$ git clone https://github.com/kaushalmodi/hugo-debugprint
#+end_src

Check status.
My file `cheatsheet.org` changes can be ignored.

#+begin_src shell
$ cd ..
$ git status

On branch master
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
	modified:   cheatsheet.org

Untracked files:
  (use "git add <file>..." to include in what will be committed)
	content/posts/cheatsheet.md
	themes/

no changes added to commit (use "git add" and/or "git commit -a")
#+end_src

I add it to git.

#+begin_src shell
$ git add .

warning: adding embedded git repository: themes/hugo-bare-min-theme
hint: You've added another git repository inside your current repository.
hint: Clones of the outer repository will not contain the contents of
hint: the embedded repository and will not know how to obtain it.
hint: If you meant to add a submodule, use:
hint: 
hint: 	git submodule add <url> themes/hugo-bare-min-theme
hint: 
hint: If you added this path by mistake, you can remove it from the
hint: index with:
hint: 
hint: 	git rm --cached themes/hugo-bare-min-theme
hint: 
hint: See "git help submodule" for more information.
warning: adding embedded git repository: themes/hugo-debugprint
warning: adding embedded git repository: themes/hugo-search-fuse-js
#+end_src

I follow the hint.

#+begin_src shell
$ git rm --cached themes/hugo-bare-min-theme

error: the following file has staged content different from both the
file and the HEAD:
    themes/hugo-bare-min-theme
(use -f to force removal)

$ git rm -f --cached themes/hugo-bare-min-theme

rm 'themes/hugo-bare-min-theme'
#+end_src

And I check the status again.

#+begin_src shell
$ ls themes/

hugo-bare-min-theme	hugo-debugprint		hugo-search-fuse-js

$ git status

On branch master
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
	modified:   cheatsheet.org
	new file:   content/posts/cheatsheet.md
	new file:   themes/hugo-debugprint
	new file:   themes/hugo-search-fuse-js

Untracked files:
  (use "git add <file>..." to include in what will be committed)
	themes/hugo-bare-min-theme/
#+end_src

Then I add files.

#+begin_src shell
$ git add .

warning: adding embedded git repository: themes/hugo-bare-min-theme
hint: You've added another git repository inside your current repository.
hint: Clones of the outer repository will not contain the contents of
hint: the embedded repository and will not know how to obtain it.
hint: If you meant to add a submodule, use:
hint: 
hint: 	git submodule add <url> themes/hugo-bare-min-theme
hint: 
hint: If you added this path by mistake, you can remove it from the
hint: index with:
hint: 
hint: 	git rm --cached themes/hugo-bare-min-theme
hint: 
hint: See "git help submodule" for more information.
#+end_src

I am confused.
But I keep trying.

#+begin_src shell
$ git add themes/hugo-bare-min-theme/
$ git status

On branch master
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
	modified:   cheatsheet.org
	new file:   content/posts/cheatsheet.md
	new file:   themes/hugo-bare-min-theme
	new file:   themes/hugo-debugprint
	new file:   themes/hugo-search-fuse-js
#+end_src

Then I commit these changes one by one.

#+begin_src shell
$ git add content/posts/cheatsheet.md
$ git add themes/hugo-bare-min-theme/
$ git add themes/hugo-debugprint/
$ git add themes/hugo-search-fuse-js/
$ git commit -m"submodule"

[master ece9977] submodule
 5 files changed, 135 insertions(+), 1 deletion(-)
 create mode 100644 content/posts/cheatsheet.md
 create mode 160000 themes/hugo-bare-min-theme
 create mode 160000 themes/hugo-debugprint
 create mode 160000 themes/hugo-search-fuse-js

$ git push origin master
#+end_src

*** Deploy: Netlify build failed

I push the source code to GitHub and use Netlify for auto-building.
Howevery, Netlify build failed with 
the error message says something wrong with submodules.

#+begin_src shell
Error checking out submodules: fatal: No url found for submodule path 'themes/hugo-bare-min-theme' in .gitmodules
Failing build: Failed to prepare repo
Failed during stage 'preparing repo': Error checking out submodules: fatal: No url found for submodule path 'themes/hugo-bare-min-theme' in .gitmodules
: exit status 128
#+end_src

I think I met this problem before when I built [[https://rustinblockchain][rib.rs]] website in Hugo.
But I can remember how I solved it at last.
(That's why I take notes now ;)

*** Remove submodules

I go inside of each theme repo, and try to remove the `.git` file.

#+begin_src shell
$ cd hugo-bare-min-theme/
$ git rm .git

fatal: pathspec '.git' did not match any files

$ git rm -rf .git

fatal: pathspec '.git' did not match any files

$ rm -rf .git

$ cd ..
$ cd hugo-debugprint/
$ rm -rf .git/
$ cd ..
$ cd hugo-search-fuse-js/
$ rm -rf .git/
#+end_src

Again, check status.

#+begin_src shell
$ cd ..
$ git submodule status

fatal: no submodule mapping found in .gitmodules for path 'themes/hugo-bare-min-theme'

$ git status
On branch master
nothing to commit, working tree clean
#+end_src

It's interesting, and I am super confusing now.
I don't know what to do, and try something unreasonable.
I go to github.com/my/repo, and delete the `.gitmodules`.
Then I `git pull` changes to my local repo.

Now check the status.

#+begin_src shell
$ git submodule status

fatal: no submodule mapping found in .gitmodules for path 'themes/hugo-bare-min-theme'

$ cat .git/modules/

cat: .git/modules/: Is a directory

$ ls .git/modules/

themes
#+end_src

I try more ways to clean these uncleared-relational submodules.

#+begin_src shell
$ git rm --cached
usage: git rm [<options>] [--] <file>...

    -n, --dry-run         dry run
    -q, --quiet           do not list removed files
    --cached              only remove from the index
    -f, --force           override the up-to-date check
    -r                    allow recursive removal
    --ignore-unmatch      exit with a zero status even if nothing matched

$ ls .git/config 

.git/config

$ cat .git/config 

[core]
	repositoryformatversion = 0
	filemode = true
	bare = false
	logallrefupdates = true
	ignorecase = true
	precomposeunicode = true
[remote "origin"]
	url = git@github.com:Aimeedeer/org-notes.git
	fetch = +refs/heads/*:refs/remotes/origin/*
[submodule "themes/hugo-bare-min-theme"]
	url = https://github.com/kaushalmodi/hugo-bare-min-theme
	active = true

$ rm -rf .git/modules/themes/
$ git status

On branch master
nothing to commit, working tree clean

$ git submodule status

fatal: no submodule mapping found in .gitmodules for path 'themes/hugo-bare-min-theme'

$ git reset
$ git status

On branch master
nothing to commit, working tree clean

$ git submodule status

fatal: no submodule mapping found in .gitmodules for path 'themes/hugo-bare-min-theme'

$ git rm themes/*

error: the following files have local modifications:
    themes/hugo-bare-min-theme
    themes/hugo-debugprint
    themes/hugo-search-fuse-js
(use --cached to keep the file, or -f to force removal)

$ git status

On branch master
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
	modified:   config.toml

no changes added to commit (use "git add" and/or "git commit -a")

$ git commit -am"config"

[master 2c206b9] config
 1 file changed, 4 insertions(+)

$ git rm -f themes/*

rm 'themes/hugo-bare-min-theme'
rm 'themes/hugo-debugprint'
rm 'themes/hugo-search-fuse-js'

$ git status

On branch master
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
	deleted:    themes/hugo-bare-min-theme
	deleted:    themes/hugo-debugprint
	deleted:    themes/hugo-search-fuse-js


$ git commit -m"rm"

[master 4404bde] rm
 3 files changed, 3 deletions(-)
 delete mode 160000 themes/hugo-bare-min-theme
 delete mode 160000 themes/hugo-debugprint
 delete mode 160000 themes/hugo-search-fuse-js
#+end_src

Finally the submodule is clean!

#+begin_src shell
$ git submodule status
#+end_src

I go back to the `themes` folder to start over.

#+begin_src shell
$ cd themes/
$ git clone https://github.com/kaushalmodi/hugo-bare-min-theme
$ cd hugo-bare-min-theme/
$ rm -rf .git
$ cd ..
$ cd ..
$ git status

On branch master
Untracked files:
  (use "git add <file>..." to include in what will be committed)
	themes/

nothing added to commit but untracked files present (use "git add" to track)

$ git add .

-bare-min-theme/exampleSite/content/post/migrate-from-jekyll.md

$ git status

On branch master
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
	new file:   themes/hugo-bare-min-theme/.gitignore
	new file:   themes/hugo-bare-min-theme/.gitmodules
	new file:   themes/hugo-bare-min-theme/LICENSE.md
	new file:   themes/hugo-bare-min-theme/README.md
	new file:   themes/hugo-bare-min-theme/archetypes/.gitkeep
	new file:   themes/hugo-bare-min-theme/config.toml
	new file:   themes/hugo-bare-min-theme/exampleSite/.dir-locals.el
	new file:   themes/hugo-bare-min-theme/exampleSite/LICENSE
	new file:   themes/hugo-bare-min-theme/exampleSite/README.md
	new file:   themes/hugo-bare-min-theme/exampleSite/config.toml
	new file:   themes/hugo-bare-min-theme/exampleSite/content/about.md
	new file:   themes/hugo-bare-min-theme/exampleSite/content/post/creating-a-new-theme.md
	new file:   themes/hugo-bare-min-theme/exampleSite/content/post/goisforlovers.md
	new file:   themes/hugo-bare-min-theme/exampleSite/content/post/hugoisforlovers.md
	new file:   themes/hugo-bare-min-theme/exampleSite/content/post/migrate-from-jekyll.md
	new file:   themes/hugo-bare-min-theme/exampleSite/content/search.md
	new file:   themes/hugo-bare-min-theme/exampleSite/exampleSite.org
	new file:   themes/hugo-bare-min-theme/exampleSite/layouts/.gitkeep
	new file:   themes/hugo-bare-min-theme/exampleSite/static/.gitignore
	new file:   themes/hugo-bare-min-theme/exampleSite/themes/.ignore
	new file:   themes/hugo-bare-min-theme/exampleSite/themes/hugo-bare-min-theme
	new file:   themes/hugo-bare-min-theme/images/screenshot.png
	new file:   themes/hugo-bare-min-theme/images/tn.png
	new file:   themes/hugo-bare-min-theme/layouts/404.html
	new file:   themes/hugo-bare-min-theme/layouts/_default/baseof.html
	new file:   themes/hugo-bare-min-theme/layouts/_default/li.html
	new file:   themes/hugo-bare-min-theme/layouts/_default/list.html
	new file:   themes/hugo-bare-min-theme/layouts/_default/single.html
	new file:   themes/hugo-bare-min-theme/layouts/_default/summary.html
	new file:   themes/hugo-bare-min-theme/layouts/_default/terms.html
	new file:   themes/hugo-bare-min-theme/layouts/index.html
	new file:   themes/hugo-bare-min-theme/layouts/partials/archive/version_ge.html
	new file:   themes/hugo-bare-min-theme/layouts/partials/header_image.html
	new file:   themes/hugo-bare-min-theme/layouts/partials/mathjax.html
	new file:   themes/hugo-bare-min-theme/layouts/partials/opengraph.html
	new file:   themes/hugo-bare-min-theme/layouts/partials/summary_minus_toc.html
	new file:   themes/hugo-bare-min-theme/layouts/partials/twitter_cards.html
	new file:   themes/hugo-bare-min-theme/layouts/shortcodes/figure2.html
	new file:   themes/hugo-bare-min-theme/netlify.toml
	new file:   themes/hugo-bare-min-theme/static/css/github_chroma.css
	new file:   themes/hugo-bare-min-theme/static/js/mathjax-config.js
	new file:   themes/hugo-bare-min-theme/theme.toml
#+end_src

I commit the changes and check the status,
and it looks clean. Great!

#+begin_src shell
$ git commit -am"theme"
$ git submodule status
#+end_src


Then I repeat the workable solution to the other two theme repos,
and push the final changes.

Netlify Build Complete!

*** Others

It is strange that I don't see other people met these problems
when I searched on Google.

I also hope I can avoid this type of problems next time,
or find better solutions.


** Hugo Code Highlight                            :hugo:hacking:css:@hacking:
:PROPERTIES:
:EXPORT_FILE_NAME: hugo-code-highlight
:EXPORT_DATE: 2020-11-14
:EXPORT_HUGO_SECTION: hacking
:EXPORT_DESCRIPTION: Hugo uses default built-in code highlight. Change it from config.toml and (maybe) add your own syntax.css.
:EXPORT_OPTIONS: toc:2
:END:


*** Disable the default

Add this code to the top level in your config.toml.
Do not put it below [Params].

#+begin_src 
pygmentsUseClasses = true
#+end_src

*** Generate your syntax.css

Hugo's doc:
[[https://gohugo.io/content-management/syntax-highlighting/][Generate Syntax Highlighter CSS]]

#+begin_src shell
hugo gen chromastyles --style=monokai > syntax.css
#+end_src

Replace "monokai" with other names [[https://xyproto.github.io/splash/docs/][here]].

Add the CSS file to the right place, for example,
> static/css/syntax.css

and add the path to your header.html or head.html,
where stylesheets are imported.

** Philosophy and Minds                    :philosophy:mind:thought:@reading:
:PROPERTIES:
:EXPORT_FILE_NAME: philosophy-and-minds
:EXPORT_DATE: 2020-11-16
:EXPORT_HUGO_SECTION: reading
:EXPORT_DESCRIPTION: Learning from great minds.
:EXPORT_OPTIONS: toc:2
:END:


[[https://www.youtube.com/watch?v=SOr1YYRljV8][Yaron Brook: Ayn Rand and the Philosophy of Objectivism | Lex Fridman Podcast #138]]

Yaron Brook introduced a lot of stories about Ayn Rand 
in this podcast.
I only read Ayn Rand's book [[https://en.wikipedia.org/wiki/Atlas_Shrugged][Atlas Shrugged]] several years ago,
and I loved it.

A shot one [[https://www.youtube.com/watch?v=oC2nWeEhvcw][Ayn Rand doesn't have all the answers, but she has all the questions | Michael Malice]].

I plan to reread [[https://www.goodreads.com/book/show/6454477-the-red-book][The Red Book]] from C.G. Jung
and Friedrich Nietzsche's books.
** Books                                              :reading:book:@reading:
:PROPERTIES:
:EXPORT_FILE_NAME: books
:EXPORT_DATE: 2020-11-13
:EXPORT_HUGO_SECTION: reading
:EXPORT_DESCRIPTION: Books I've read. 
:EXPORT_OPTIONS: toc:2
:END:

Aimee's [goodreads](https://www.goodreads.com/user/show/90889710-aimee-zhu)


*** 2020

- Guns, Germs, and Steel: The Fates of Human Societies
- [[https://www.amazon.com/Art-War-AmazonClassics-Sun-Tzu-ebook/dp/B073QR86XF/ref=sr_1_4][The Art of War]]
- [[https://www.amazon.com/15-Minute-Read-Power-Subconscious-ebook/dp/B08541YNTW/ref=rtpb_2/138-2049715-3003242][The Power of Your Subconscious Mind]]
- [[https://landing.coingecko.com/how-to-defi/][How to DeFi]]
- [[https://www.goodreads.com/book/show/38819529-the-hobbit][The Hobbit]]
- [[https://www.goodreads.com/book/show/50491494-options-trading-crash-course][Options Trading Crash Course]]
- [[https://www.amazon.com/Franklins-Autobiography-Eclectic-English-Classics-ebook/dp/B0052GE5GC/][Franklin's Autobiography]]
- [[https://www.goodreads.com/notes/38145718-thomas-edison/90889710-aimee-zhu][Thomas Edison: A Captivating Guide to the Life of a Genius Inventor]]
- [[https://www.amazon.com/Elements-Style-Fourth-William-Strunk-ebook/dp/B07NPN5HTP/ref=sr_1_4][The elements of style]]
- [[https://www.amazon.com/Out-My-Mind-Sharon-Draper-ebook/dp/B003ATPRNI/ref=sr_1_3][Out of my mind]]
- [[https://www.amazon.com/Manage-Your-Day-Day-Creative-ebook/dp/B00B77UE4W/ref=sr_1_2][Manage Your Day-to-Day: Build Your Routine, Find Your Focus, and Sharpen Your Creative Mind]]
- [[https://www.amazon.com/Animal-Farm-Fairy-Modern-Classic-ebook/dp/B003K16PUU/ref=sr_1_1][Animal Farm]]
- [[https://www.amazon.com/Decisions-Death-Street-Kindle-Single-ebook/dp/B00TO1J78M/ref=sr_1_1][Decisions: Life and Death on Wall Street]]
- [[https://www.amazon.com/Little-Still-Market-Books-Profits-ebook/dp/B003VWCQB0/ref=sr_1_1][The Little Book that Still Beats the Market]]
- [[https://www.amazon.com/If-You-Tell-Unbreakable-Sisterhood-ebook/dp/B07Q5TL9SQ/ref=sr_1_3][If You Tell: A True Story of Murder, Family Secrets, and the Unbreakable Bond of Sisterhood]]
- [[https://www.amazon.com/Think-Grow-Rich-Napoleon-Hill-ebook/dp/B08776ZZY4/ref=sr_1_3][Think and Grow Rich]]
- [[https://www.goodreads.com/notes/36992849-work-less-make-more/90889710-aimee-zhu?ref=bsop][Work Less, Make More]]
- 卡耐基自传
  - ref: origin [[https://www.amazon.com/Autobiography-Andrew-Carnegie-Gospel-Classics-ebook/dp/B002G54Y3Q/ref=sr_1_4][The Autobiography of Andrew Carnegie and The Gospel of Wealth]]
- [[https://www.amazon.cn/dp/B087JNZ6ZL/ref=sr_1_1][一生的旅程：迪士尼 CEO 自述]]
  - ref: origin [[https://www.amazon.com/gp/product/0399592091/ref=ox_sc_act_title_1][The Ride of a Lifetime: Lessons Learned from 15 Years as CEO of the Walt Disney Company]]
- [[https://www.goodreads.com/book/show/51957605][股票作手回忆录]]
  - ref: origin [[https://www.amazon.com/REMINISCENCES-STOCK-OPERATOR-Edwin-Lefevre-ebook/dp/B07ND35YTJ/ref=tmm_kin_swatch_0][Reminiscences of a Stock Operator]]
- [[https://www.amazon.cn/dp/B00U3NDI1C/ref=sr_1_1][黄金屋：宏观对冲基金顶尖交易者的掘金之道]]
  - ref: origin [[https://www.amazon.com/Inside-House-Money-Traders-Profiting-ebook/dp/B00GYXP8CW/ref=sr_1_1][Inside the House of Money: Top Hedge Fund Traders on Profiting in the Global Markets]]
- [[https://www.goodreads.com/book/show/35561327][一本小小的红色写作书]]
- [[https://www.amazon.cn/dp/B01HRYE86S/ref=sr_1_1][血疫:埃博拉的故事]]
  - ref: origin [[https://www.amazon.com/Hot-Zone-Terrifying-Story-Origins-ebook/dp/B007DCU4IQ/ref=sr_1_1][The Hot Zone: The Terrifying True Story of the Origins of the Ebola Virus]]

** How to Read and Write                        :writing:notes:read:@writing:
:PROPERTIES:
:EXPORT_FILE_NAME: how-to-read-and-write
:EXPORT_DATE: 2020-10-29
:EXPORT_HUGO_SECTION: writing
:EXPORT_DESCRIPTION: Notes about reading and writing.
:EXPORT_OPTIONS: toc:2
:END:

*** Read books
[[https://zettelkasten.de/posts/barbell-method-reading/][
The Barbell Method of Reading]]

The Barbell Method takes this into account by integrating 
your reading habit into your knowledge work with two steps:

**Read the book**. Read swiftly but don’t skip any parts 
unless they make you vomit or put you to sleep. 
Mark all the passages that stand out and contain useful, 
interesting or inspiring information.

**Read the book a second time**. But now you read 
the marked parts only. This time you make notes, 
connect them to past notes (Zettelkasten Method!) 
and think about what you’ve read. 
Make mindmaps, drawings, bullet points – 
everything that helps you to think more clearly.

The quality of the book will now determine 
how much time you invest in it. 
Sometimes, a book is not that important and 
only provides a few shallow pieces of information. 
The second step could only take 
a very short period of time. But a good book is dense. 

True reading is not a passive process in which 
you just create an influx of information. 
It consists of deep processing, thinking and writing on 
what you have read and interconnecting it with you already know.

Only the three parts combined, reading, thinking, and writing, 
produce a true change in your brain and make you a better thinker. 
To write about what you read is important even if 
you don’t aim to write books on something. 
Still, you have to write if you want to think properly. 
Still, you have to write to process information properly.

Don’t try to impress anyone with things you don’t have invested energy into.

At last, you are what you practice regularly. 
You are your habits. If your habits don’t include 
to really gnaw on ideas and concepts, 
you won’t sharpen your mental teeth. 
So if you want to be able to think deeply 
and properly, practice it.

The Zettelkasten Method is designed to serve several different purposes:

- Optimize the amount of information you process. You should read a lot.
- Produce an archive which consists of true knowledge, not just a collection of half-understood bits of random points.
- Learn to think deeply and thoroughly by making it a habit to practice it.

*** Read papers

[[https://web.stanford.edu/class/ee384m/Handouts/HowtoReadPaper.pdf][How to Read Paper]]

THE THREE-PASS APPROACH

The key idea is that you should read the paper in up to
three passes, instead of starting at the beginning 
and plowing your way to the end. Each pass accomplishes specific
goals and builds upon the previous pass: 
The first pass gives you a general idea about the paper. 
The second pass lets you grasp the paper’s content, but not its details. 
The third pass helps you understand the paper in depth.


The first pass is a quick scan to get a bird’s-eye view of
the paper. You can also decide whether you need to do any
more passes. This pass should take about five to ten minutes
and consists of the following steps:
1. Carefully read the title, abstract, and introduction
2. Read the section and sub-section headings, but ignore everything else
3. Read the conclusions
4. Glance over the references, mentally ticking off the ones you’ve already read

At the end of the first pass, you should be able to answer the five Cs:
1. Category: What type of paper is this? 
A measurement paper? An analysis of an existing system? 
A description of a research prototype?
2. Context: Which other papers is it related to? Which
theoretical bases were used to analyze the problem?
3. Correctness: Do the assumptions appear to be valid?
4. Contributions: What are the paper’s main contributions?
5. Clarity: Is the paper well written?

Incidentally, when you write a paper, you can expect most
reviewers (and readers) to make only one pass over it. Take
care to choose coherent section and sub-section titles and
to write concise and comprehensive abstracts. If a reviewer
cannot understand the gist after one pass, the paper will
likely be rejected; if a reader cannot understand 
the highlights of the paper after five minutes, the paper will likely
never be read.

In the second pass, read the paper with greater care, but
ignore details such as proofs. It helps to jot down the key
points, or to make comments in the margins, as you read.

To fully understand a paper, particularly if you are 
reviewer, requires a third pass. The key to the third pass
is to attempt to virtually re-implement the paper: that is,
making the same assumptions as the authors, re-create the
work. By comparing this re-creation with the actual paper,
you can easily identify not only a paper’s innovations, but
also its hidden failings and assumptions.


This pass requires great attention to detail. You should
identify and challenge every assumption in every statement.
Moreover, you should think about how you yourself would
present a particular idea. This comparison of the actual
with the virtual lends a sharp insight into the proof and
presentation techniques in the paper and you can very likely
add this to your repertoire of tools. During this pass, you
should also jot down ideas for future work.

This pass can take about four or five hours for beginners,
and about an hour for an experienced reader. At the end
of this pass, you should be able to reconstruct the entire
structure of the paper from memory, as well as be able to
identify its strong and weak points. In particular, you should
be able to pinpoint implicit assumptions, missing citations
to relevant work, and potential issues with experimental or
analytical techniques.

I’ve used this approach for the last 15 years 
to read conference proceedings, write reviews, 
do background research,
and to quickly review papers before a discussion. 
This disciplined approach prevents me from drowning in the details
before getting a bird’s-eye-view. It allows me to estimate the
amount of time required to review a set of papers. 
Moreover, I can adjust the depth of paper evaluation depending
on my needs and how much time I have.

If you are reading a paper to do a review, you should also
read Timothy Roscoe’s paper on “[[http://people.inf.ethz.ch/troscoe/pubs/review-writing.pdf][Writing reviews for systems conferences]]”. 
If you’re planning to write a technical
paper, you should refer both to 
[[http://www.cs.columbia.edu/hgs/etc/writingstyle.html][Henning Schulzrinne’s comprehensive website]] 
and [[http://www.che.iitm.ac.in/misc/dd/writepaper.pdf][George Whitesides’s excellent overview of the process]]. 
Finally, Simon Peyton Jones has a website 
that covers [[http://research.microsoft.com/simonpj/Papers/givinga-talk/giving-a-talk.htm][the entire spectrum of research skills]].

*** How to write

Very well written, and I learned a lot from
Timothy Roscoe’s paper on “[[http://people.inf.ethz.ch/troscoe/pubs/review-writing.pdf][Writing reviews for systems conferences]]”.
This is the paper worth reading many times,
and follow his practice.

**First of all, summarize the paper. **
Give a neutral description of what you think the paper
is about, where the authors are coming from, 
why they view the problem as important,
and what they’ve done. 
This is a great way to start writing a review, 
particularly when you’re not sure how to get started.

**Second, state what you think the contributions are.** 
It’s rare to find a paper that completely fails to 
make any contributions, but it’s much more common to find one that
makes no useful contributions, 
or contributions that turn out to be flawed. 
In any case, state what the authors think the contributions are, 
or, if you think there’s a contribution
you think they’ve missed, what it is. 
A surprisingly common mistake among paper
authors is to fail to state the contribution - 
if that’s the case, gently point this out (see
“Tone” below), but try to fill it in.

**Next, give your specific comments** on the paper 
by working through the scribbles you made 
on first (or second) reading. 
Often you may find your opinion has changed in the meantime, 
which is fine (you may even have learned something!). 
Some reviewers like to separate their comments 
into technical discussion, and then small points like typos
and other mistakes, often referred to as “nits”.

<some good suggestions in between>

Finally, provide some kind of conclusion at the end. 
If you like, summarize the good
points and bad points separately, 
but the important thing is to give 
a brief recommendation for the paper and your reasons for it.

**Consequently, tone is important.**

Rather than saying “this paper doesn’t cite Multics, which did everything you do and
more”, it’s better to say something like “This paper reminded me of Multics, which
seems quite similar. I would find the paper more persuasive if it stated what the authors
do over and above Multics.”

Also bear in mind that, in all cases, there is a still a remote possibility that you’ve
misunderstood the paper. Hence, a flat assertion like “The algorithm given in the paper
breaks in the presence of Byzantine faults” is risky, and may be unfair to the authors.
It’s better to write “The description in the paper left me worried that algorithm breaks
in the presence of Byzantine faults.”, preferably followed by a sketch of why you think
this is the case.

**Conclusion**

Writing a good review is important: it helps the authors do better work, it helps you
to learn more about the subject being reviewed, and it makes you look good in front
of your peers. Surprisingly, it can also be fun – even writing a review for a really bad
paper can be rewarding if it forces you to explain concepts afresh in a new context.

*** Articles about writing

[[http://www.paulgraham.com/useful.html][How to write usefully]]

[[https://www.gwern.net/About#writing-checklist][Gwern's writing checklist]]
[[https://www.nngroup.com/articles/how-people-read-online/][
How people read online]]

** Rust China                               :rust:china:community:@community:
:PROPERTIES:
:EXPORT_FILE_NAME: rust-china
:EXPORT_DATE: 2020-11-20
:EXPORT_HUGO_SECTION: community
:EXPORT_DESCRIPTION: All about Rust China.
:EXPORT_OPTIONS: toc:2
:END:

*** Companies using Rust

- Alibaba & Ant Finance
  - Multiple teams & products
  - [[https://occlum.io/][Occlum]] and the [[https://github.com/occlum/occlum][source]] # ~tee~
- [[https://www.huawei.com/en/][Huawei]]
  - Multiple teams & products
- [[https://www.cryptape.com/][Cryptape]] # ~blockchain~
  - [[https://github.com/nervosnetwork/ckb][CKB]]
- [[https://www.rivtower.com/][RivTower 溪塔科技]] # ~blockchain~
  - [[https://github.com/citahub/cita][CITA]]
- [[https://pingcap.com/][PingCAP]] # ~database~
  - [[https://github.com/tikv/tikv][TiKV]]
- [[https://www.bilibili.com/][Bilibili]] # ~video~ ~social~
- [[https://www.bytedance.com/en/][Bytedance]] # ~video~ ~social~
- [[https://www.zhihu.com/][Zhihu]] # ~forum~
  - [[https://github.com/zhihu/rucene][Rucene]]

*** Conferences

[[https://2020conf.rustcc.cn/][Rust China Conf 2020]] | Shanghai or Shenzhen
- Source code?
- Organizing by [[https://rustcc.cn/][RustCC]] 

[[https://rustcon.asia][RustCon Asia 2019]] | Beijing
- Source code is on [[https://github.com/rustcon-asia/beijing-2019][GitHub]]
- Co-organized by [[https://www.cryptape.com/][Cryptape]] and [[https://pingcap.com/][PingCAP]]
- Announcement: [[https://rustcon.asia/blog/hello-asia/][Hello / 你好 Asia]]
- Recap: [[https://medium.com/@Aimeedeer/a-close-touch-with-rust-community-4a8507b756d9][A Close Encounter with Rust Community]]
- [[https://www.dropbox.com/sh/t6s39rupk492ntq/AACSMbbeE-uYLqqlyJmXXGUPa?dl=0][Photos]]
- [[https://www.youtube.com/watch?v=YSEx8wtlPWc&list=PL85XCvVPmGQjPvweRqkBgnh_HKE5MBB8x][Videos]]

*** GitHub Orgs

- https://github.com/rust-lang-cn
- https://github.com/RustChina
- https://github.com/rust-zh


*** Forums and Channels

**** Forum and media

- Forum RustCC: https://rustcc.cn/
- WeChat news channel: Rust语言学习交流
- Telegram news channel: https://t.me/rust_daily_news

**** Telegram

- https://t.me/rust_zh
- https://t.me/rust_deep_water
- https://t.me/rust_tw  

**** WeChat groups

Invite only because of WeChat's limitation.

**** QQ groups

- Rust编程语言社区1群，群号：303838735 （已满，只能内部邀请）
- Rust编程语言社区2群，群号：813448660
- Rust中文，群号：570065685
- Topics: 专题群：
  - Rust Redox发行版开发群，群号：437268658
  - Rust Data Science 研究小组，群号：681142501
  - Rust webassembly/wasm社区，群号：347929175
  - Rust 论坛开发组，群号：687763184 
   （关于https://rust.cc论坛开发相关讨论）
  - Rust社群-区块链研究，群号：617238820
  - Rust 嵌入式开发，群号：825820683
  - φ Rust图形学，群号：812748521
  - 哲学与计算，群号：446590168
  - Offline meetups: 地方线下聚会群：
    - 北京：305842562
    - 上海：966129249
    - 深圳：673715651
    - 广州：738772514
    - 成都：131080784
    - 重庆：962149536

